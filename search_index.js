var documenterSearchIndex = {"docs":
[{"location":"itensors/#ITensor-extension","page":"ITensor extension","title":"ITensor extension","text":"","category":"section"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"FuzzifiED also supports an ITensor extension, including convertion with the Site and OpSum objects from ITensor library and management of DMRG sweeping process. To use the extension, make sure the packages ITensors, ITensorMPS are properly installed, and include","category":"page"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"using ITensors, ITensorMPS","category":"page"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"at the heading of the Julia script.","category":"page"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"During intialisation, the optimal configuration for parallelisation is already automatically set.","category":"page"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"BLAS.set_num_threads(1);\nNDTensors.Strided.disable_threads();\nITensors.enable_threaded_blocksparse();","category":"page"},{"location":"itensors/#Format-conversion","page":"ITensor extension","title":"Format conversion","text":"","category":"section"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"FuzzyfiED defines a new SityType \"FuzzyFermion\" that can be initialised from QNDiags to avoid overwriting the original \"Fermion\" type.","category":"page"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"ITensors.space( :: SiteType\"FuzzyFermion\"; o :: Int, qnd :: Vector{QNDiag})","category":"page"},{"location":"itensors/#ITensors.space-Tuple{SiteType{FuzzyFermion}}","page":"ITensor extension","title":"ITensors.space","text":"ITensors.space( :: SiteType\"FuzzyFermion\" ; o :: Int, qnd :: Vector{QNDiag})\n\nDefine a new site type \"FuzzyFermion\" which inherits all the features of ITensor type \"Fermion\". It can be initialised by a set of QNDiag's and the site index o.\n\n\n\n\n\n","category":"method"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"The Sites objects in ITensor can be converted to a QNDiags and Confs with the QNs extracted. ","category":"page"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"Vector{QNDiag}(sites :: Vector{Index{Vector{Pair{QN, Int64}}}})\nConfs(sites :: Vector{Index{Vector{Pair{QN, Int64}}}}, sec_qn :: QN)","category":"page"},{"location":"itensors/#Base.Vector-Union{Tuple{Vector{Index{Vector{Pair{QN, Int64}}}}}, Tuple{QNDiag}} where QNDiag","page":"ITensor extension","title":"Base.Vector","text":"Vector{QNDiag}(sites :: Vector{<:Index})\n\nConverts a Sites object in the ITensors package to a set of QNDiags. \n\nArguments\n\nsites :: Vector{<:Index} is a Sites object. Only Fermion site type is supported, and the quantum numbers of the 0 state must be all zero. Note that this will subject to the limitation in ITensors that the number of conserved quantities must be less than 4.\n\n\n\n\n\n","category":"method"},{"location":"itensors/#FuzzifiED.Confs-Tuple{Vector{Index{Vector{Pair{QN, Int64}}}}, QN}","page":"ITensor extension","title":"FuzzifiED.Confs","text":"Confs(sites :: Vector{<:Index}, sec_qn :: QN)\nConfs(sites :: Vector{<:Index}, cf_ref :: Vector{Int64})\n\nConverts a Sites object in the ITensors package to the Confs object\n\nArguments\n\nsites :: Vector{<:Index} is a Sites object. Only Fermion site type is supported, and the quantum numbers of the 0 state must be all zero. Note that this will subject to the limitation in ITensors that the number of conserved quantities must be less than 4. \nsec_qn :: QN is a QN object that specifies the the quantum number of the selected configuration. Alternatively, cf_ref :: Vector{Int64}) is a reference configuration composed of 0 and 1.\n\n\n\n\n\n","category":"method"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"Conversely, the  Sites objects in ITensors can also be generated from a set of diagonal quantum numbers ","category":"page"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"GetSites(qnd :: Vector{QNDiag})","category":"page"},{"location":"itensors/#FuzzifiED.GetSites-Tuple{Vector{QNDiag}}","page":"ITensor extension","title":"FuzzifiED.GetSites","text":"GetSites(qnd :: Vector{QNDiag}) :: Vector{<:Index}\n\nreturns the ITensors Sites of type \"FuzzyFermion\" from a set of QNDiags.\n\n\n\n\n\n","category":"method"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"If the number of quantum numbers are too many, it can be truncated by ","category":"page"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"TruncateQNDiag(qnd :: Vector{QNDiag} ; trunc_lth :: Int64 = 3, trunc_wt :: Vector{Int64} = [ 10 ^ (i - trunc_lth) for i = trunc_lth : length(qnd)]) ","category":"page"},{"location":"itensors/#FuzzifiED.TruncateQNDiag-Tuple{Vector{QNDiag}}","page":"ITensor extension","title":"FuzzifiED.TruncateQNDiag","text":"TruncateQNDiag(qnd :: Vector{QNDiag} ; trunc_lth :: Int64, trunc_wt :: Vector{Int64}) :: Vector{QNDiag}\n\ntruncates the list of N_U QNDiags from to a number N_U acceptable by ITensors. The new quantum numbers are \n\nbeginaligned\n    Q_1=Q_1 Q_2=Q_2  Q_N_U-1=Q_N_U-1\n    Q_N_U=λ_N_UQ_N_U+λ_N_U+1Q_N_U+1++λ_N_UQ_N_U\nendaligned\n\nArguments\n\nqnd :: Vector{QNDiag} stores the set of QNDiags. \ntrunc_lth :: Int64 stores the truncated numbers of QNDiags. Facultative, 3 by default. \ntrunc_wt :: Vecotr{Int64} stores the N_U-N_U+1 coefficients λ. Facultative, 1101001000 by default. \n\n\n\n\n\n","category":"method"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"The OpSum objects in ITensor can be converted with the collection of Term's","category":"page"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"Terms(opsum :: Sum{Scaled{ComplexF64, Prod{Op}}})\nOpSum(tms :: Terms)","category":"page"},{"location":"itensors/#FuzzifiED.Terms-Tuple{Sum{Scaled{ComplexF64, Prod{Op}}}}","page":"ITensor extension","title":"FuzzifiED.Terms","text":"Terms(opsum :: OpSum)\n\nConverts a OpSum object in ITensors to a series of terms. Note that the only operators supported are \"C\", \"Cdag\" \"N\" and \"I\".\n\n\n\n\n\n","category":"method"},{"location":"itensors/#ITensors.Ops.OpSum-Tuple{Vector{Term}}","page":"ITensor extension","title":"ITensors.Ops.OpSum","text":"OpSum(tms :: Terms)\n\nConverts a series of terms to OpSum object in ITensors.\n\n\n\n\n\n","category":"method"},{"location":"itensors/#Easy-sweep","page":"ITensor extension","title":"Easy sweep","text":"","category":"section"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"This tool kit facilitates the management of DMRG process. It automatically records the intermediate results and recover these results if a job is stopped and run again on HPC. It also manages the gradual increase of maximal bond dimensions and the determination of convergence by the criteria of energy. This extension required the packages HDF5. We also recommand using the package ITensorMPOConstruction for the generation of Hamiltonian MPO, which can be installed by ","category":"page"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"using Pkg ; Pkg.add(url=\"https://github.com/ITensor/ITensorMPOConstruction.jl.git\")","category":"page"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"EasySweep(id :: String, hmt :: MPO, st00 :: MPS ; path :: String = \"./\", dim_list :: Vector{Int64} = [1000,2000,3000,4000,5000,6000], proj :: Vector{String} = String[], e_tol1 :: Float64 = 1E-6, e_tol :: Float64 = 1E-7, cutoff :: Vector{Float64} = [1E-9], maxdim0 :: Vector{Int64} = [10,20,50,100,200,500], noise0 :: Vector{Float64} = [1E-4,3E-5,1E-5,3E-6,1E-6,3E-7], noise :: Vector{Float64} = [1E-6,2E-7,5E-8,1E-8,0], nsweeps :: Int64 = 10, weight :: Float64 = 100.0, observer :: AbstractObserver = EasySweepObserver(e_tol1))\nSweepOne(id :: String, hmt :: MPO, st0 :: MPS, dim1 :: Int64 ; path :: String = \"./\", cutoff :: Vector{Float64} = [1E-9], maxdim :: Vector{Int64} = [dim1], nsweeps :: Int64 = 10, noise :: Vector{Float64} = [1E-6,1E-7,0], proj :: Vector{String} = String[], e_tol :: Float64 = 1E-6, weight :: Float64 = 100.0, observer :: AbstractObserver = EasySweepObserver(e_tol))\nGetMPOSites(id :: String, tms :: Union{Terms, Sum{Scaled{ComplexF64, Prod{Op}}}}, qnd :: Vector{QNDiag} ; path :: String = \"./\", mpo_method :: Function = MPO)\nGetMPO(id :: String, tms :: Union{Terms, Sum{Scaled{ComplexF64, Prod{Op}}}}, sites :: Vector{<:Index} ; path :: String = \"./\", mpo_method :: Function = MPO)","category":"page"},{"location":"itensors/#FuzzifiED.EasySweep-Tuple{String, MPO, MPS}","page":"ITensor extension","title":"FuzzifiED.EasySweep","text":"EasySweep(id :: String, hmt :: MPO, st00 :: MPS ; path :: String, dim_list :: Vector{Int64}, proj :: Vector{String}, e_tol1 :: Float64, e_tol :: Float64, cutoff :: Vector{Float64}, maxdim0 :: Vector{Float64}, noise0 :: Vector{Float64}, noise :: Vector{Int64}, nsweeps :: Int64, weight :: Float64, observer :: AbstractObserver) :: Tuple{Float64, MPS}\n\nFunction\n\nThis function automatically performs several rounds of DMRG sweeps with increasing bond dimensions. It first checks the file st_$(id).h5 in a specified repository. If the key st_fin exists, it reads the energy and MPS from the file and return the energy and MPS, otherwise it will perform the DMRG process. For each round, it will try to access the results from the key st_d$(dim_i) in st_$(id).h5, where dim_i is either 0 representing the initial round, or an element of array dim_list. If the key exist, it will read the result ; otherwise it will perform the sweeps using SweepOne. For the initial round, it will take the initial state from st00, the maximal bond dimensions from maxdim0, noise from noise0 and record the results in the key E_d0 and st_d0 in st_$(id).h5. For each of the following round, it will take the result from the previous round as the initial state and perform nsweeps sweeps with the bond dimension dim_list[i]. Each round will be stopped if the energy difference is less than e_tol1. The entire process will be stopped if the energy difference between two rounds is less than e_tol or the bond dimension of the result is less than 0.9 times the maximal bond dimension. The projected states will be accessed from the files specified by proj. It will try to access first the states with the same bond dimension as the projected states. If such states do not exist, it will then access the final state. The resulting energy will be written into the key E_fin in the file st_$(id).h5, and the MPS written into st_fin. The function returns a tuple of energy and the final MPS. \n\nArguments\n\nid :: String is a string identifying the file to which the results will be accessed and written.\nhmt :: MPO is an MPO specifying the Hamiltonian.\nst00 :: MPS is an MPS specifying the initial state. \npath :: String identifies the path where the results will be accessed and stored. Facultative, ./ by default. \ndim_list :: Vector{Int64} :: Int64 is a list that specifies the maximal bond dimensions of each round of sweeps starting from the second round. Facultative, [1000,2000,3000,4000,5000,6000] by default\nproj :: Vector{String} specifies the name of the states that will be projected. Facultative, empty by default. \ne_tol1 :: Float64 specifies the energy tolerence as a criteria to end the round of sweeps for each round of sweeps. Facultative, 1E-6 by default. \ne_tol :: Float64 specifies the energy tolerence as a criteria to end the entire process. Facultative, 1E-7 by default. \ncutoff :: Vector{Float64} is the cutoff that will be sent into DMRG. Facultative, [1.E-9] by default. \nmaxdim0 :: Vector{Int64} specifies the maximal bond dimensions of the first round of sweeps. Facultative, [10,20,50,100,200,500] by default. \nnoise0 :: Vector{Float64} specifies the noise of each sweep in the initial round and will be sent into DMRG. Facultative, [1E-4,3E-5,1E-5,3E-6,1E-6,3E-7] by default. \nnoise :: Vector{Float64} specifies the noise of each sweep from the second round and will be sent into DMRG. Facultative, [1E-6,1E-7,0] by default. \nnsweeps :: Int64 specifies the number of sweeps in each round from the second rounds. Facultative, 10 by default. \nweight :: Float64 specifies the weight of projected states and will be sent into DMRG. Facultative, 100.0 by default.\nobserver :: AbstractObserver specifies the measurement and cutoff condition for each sweep starting from the second round. Facultative, by default the observer will print the energy and cutoff once the energy difference is less than e_tol at each sweep. \ndmrg_options :: Dict specifies other options to be sent into DMRG. E.g., to specify write_when_maxdim_exceeds = 1000 and write_path = \"./tmp/\", one can put dmrg_options = Dict(:write_when_maxdim_exceeds => 1000, :write_path => \"./tmp/\").\nclear_previous :: Bool. If set true, the file st_$(id).h5 will be removed and the calculation will start from scratch. Facultative, false by default.\n\n\n\n\n\n","category":"method"},{"location":"itensors/#FuzzifiED.SweepOne-Tuple{String, MPO, MPS, Int64}","page":"ITensor extension","title":"FuzzifiED.SweepOne","text":"SweepOne(id :: String, hmt :: MPO, st0 :: MPS, dim1 :: Int64 ; path :: String, cutoff :: Vector{Float64}, maxdim :: Vector{Int64}, nsweeps :: Int64, noise :: Vector{Float64}, proj :: Vector{String}, e_tol :: Float64, weight :: Float64, observer :: AbstractObserver, dmrg_options :: Dict, dmrg_options :: Dict) :: Tuple{Float64, MPS}\n\nFunction\n\nThis function performs one round of nsweeps sweeps. It first checks the file st_$(id).h5 in a specified repository. If the key st_d$(dim1) exists, it reads the energy and MPS from the file and return the energy and MPS, otherwise it will perform the DMRG process with the maximal bond dimension specified by maxdim if it exists, or dim1. The projected states will be read from the key st_d$(dim1) if it exists or st_fin in the file st_$(fi).h5 in the same repository for each string fi in the array proj. The sweeps will be ended if the energy difference is less than etol or whatever criteria is given in observer. The resulting energy will be written into the key E_d$(dim1) in the file st_$(id).h5, and the MPS written into st_d$(dim1). The function returns a tuple of energy and the final MPS. \n\nArguments\n\nid :: String is a string identifying the file to which the results will be accessed and written.\nhmt :: MPO is an MPO specifying the Hamiltonian.\nst0 :: MPS is an MPS specifying the initial state. \ndim1 :: Int64 is a bond dimension that will be used to identify the result. \npath :: String identifies the path where the results will be accessed and stored. Facultative, ./ by default. \ncutoff :: Vector{Float64} is the cutoff that will be sent into DMRG. Facultative, [1.E-9] by default. \nmaxdim :: Vector{Int64} specifies the maximal bond dimension of each sweep. Facultative, [dim1] by default. \nnsweeps :: Int64 specifies the number of sweeps in the round. Facultative, 10 by default. \nnoise :: Vector{Float64} specifies the noise of each sweep and will be sent into DMRG. Facultative, [1E-6,1E-7,0] by default. \nproj :: Vector{String} specifies the name of the states that will be projected. Facultative, empty by default. \ne_tol :: Float64 specifies the energy tolerence as a criteria to end the sweeps. Facultative, 1E-6 by default. \nweight :: Float64 specifies the weight of projected states and will be sent into DMRG. Facultative, 100.0 by default.\nobserver :: AbstractObserver specifies the measurement and cutoff condition for each sweep. Facultative, by default the observer will print the energy and cutoff once the energy difference is less than e_tol at each sweep. \ndmrg_options :: Dict specifies other options to be sent into DMRG. E.g., to specify write_when_maxdim_exceeds = 1000 and write_path = \"./tmp/\", one can put dmrg_options = Dict(:write_when_maxdim_exceeds => 1000, :write_path => \"./tmp/\").\n\n\n\n\n\n","category":"method"},{"location":"itensors/#FuzzifiED.GetMPOSites-Tuple{String, Union{Sum{Scaled{ComplexF64, Prod{Op}}}, Vector{Term}}, Vector{QNDiag}}","page":"ITensor extension","title":"FuzzifiED.GetMPOSites","text":"GetMPOSites(id :: String, tms, qnd :: Vector{QNDiag} ; path :: String, qnu_o :: Vector{Vector{Int64}}, qnu_name :: Vector{String}, modul :: Vector{Int64}, mpo_method :: Function) :: Tuple{MPO, Vector{<:Index}}\n\nFunction\n\nThis function returns the MPO and sites for a given operator and a Hilbert space with given quantum numbers. It first checks the file op_$(id).h5 in a specified repository. If the file exists, it will try to read the fields mpo and sites and return the MPO and Sites. Otherwise it will first generates the sites with the quantum numbers given in qnu_o, qnu_name and modul (these objects are often results of a function named Get*Qnu). Then it will generate the MPO with the terms of the operator given in tms. The MPO and sites will be written into the file op_$(id).h5 in the fields mpo and sites. \n\nArguments\n\nid :: String is a string identifying the file to which the results will be accessed and written.\ntms :: Terms or tms :: OpSum is either an array of terms or a OpSum objects that specifies the expression of the operator. \nqnd :: Vector{QNDiag} is a list of diagonal quantum numbers. \npath :: String identifies the path where the results will be accessed and stored. Facultative, ./ by default. \nmpo_method :: Function is a function mpo_method(os :: OpSum, sites :: Sites) :: MPO that generates the MPO from OpSum and Sites. Facultative, MPO by default. We suggest using MPO_new in ITensorMPOConstruction package. See example_ising_dmrg_easysweep.jl for example. N.b., MPO_new only applies to the cases that the operator do not carry charge under any of the quantum numbers.\nclear_previous :: Bool. If set true, the file op_$(id).h5 will be removed and the calculation will start from scratch. Facultative, false by default.\n\n\n\n\n\n","category":"method"},{"location":"itensors/#FuzzifiED.GetMPO-Tuple{String, Union{Sum{Scaled{ComplexF64, Prod{Op}}}, Vector{Term}}, Vector{<:Index}}","page":"ITensor extension","title":"FuzzifiED.GetMPO","text":"GetMPO(id :: String, tms :: Union{Terms, OpSum}, sites :: Vector{<:Index} ; path :: String, mpo_method :: Function) :: MPO\n\nFunction\n\nThis function returns the MPO for a given operator and a given set of sites. It first checks the file op_$(id).h5 in a specified repository. If the file exists, it will try to read the fields mpo and return the MPO it has read. Otherwise it will generate the MPO with the terms of the operator given in tms. The MPO and Sites will be written into the file op_$(id).h5 in the fields mpo. \n\nArguments\n\nid :: String is a string identifying the file to which the results will be accessed and written.\ntms :: Terms or tms :: OpSum is either an array of terms or a OpSum objects that specifies the expression of the operator. \nsites :: Vector{<:Index} specifies the sites that the operator is acting on. \npath :: String identifies the path where the results will be accessed and stored. Facultative, ./ by default. \nmpo_method :: Function is a function mpo_method(os :: OpSum, sites :: Sites) :: MPO that generates the MPO from OpSum and Sites. Facultative, MPO by default. We suggest using MPO_new in ITensorMPOConstruction package. See example_ising_dmrg_easysweep.jl for example. N.b., MPO_new only applies to the cases that the operator do not carry charge under any of the quantum numbers.\nclear_previous :: Bool. If set true, the file op_$(id).h5 will be removed and the calculation will start from scratch. Facultative, false by default.\n\n\n\n\n\n","category":"method"},{"location":"itensors/#Modified-version-of-ITensor","page":"ITensor extension","title":"Modified version of ITensor","text":"","category":"section"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"We have forked ITensors and made some modifications to better suit our need. To install the modified packages, please use ","category":"page"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"using Pkg \nPkg.add(url=\"https://github.com/FuzzifiED/ITensors.jl.git\")\nPkg.add(url=\"https://github.com/FuzzifiED/ITensorMPS.jl.git\")\nPkg.add(url=\"https://github.com/FuzzifiED/ITensorMPOConstruction.jl.git\")","category":"page"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"The modifications made include","category":"page"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"Modify ITensors to allow up to 10 quantum numbers ; \nModify ITensorMPS to allow write_when_maxdim_exceeds in DMRG in the presence of projection matrices ;\nModify ITensorMPOConstruction to allow building MPOs that has symmetry flux ;\nModify ITensorMPOConstruction to allow compatibility with the newest version of ITensors.","category":"page"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"Please be warned that the robustness and the backward compatibility of these modifications are not warranted. ","category":"page"},{"location":"core/#Core-functions","page":"Core functions","title":"Core functions","text":"","category":"section"},{"location":"core/#Environment-parameters","page":"Core functions","title":"Environment parameters","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The following environment parameters defines how FuzzifiED works, viz. whether it outputs logs, how many threads it uses and where it reads its libraries. In general, you can keep it at default. ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"FuzzifiED.SilentStd\nFuzzifiED.NumThreads\nFuzzifiED.Libpath\nFuzzifiED.ElementType\nFuzzifiED.OpenHelp!()","category":"page"},{"location":"core/#FuzzifiED.SilentStd","page":"Core functions","title":"FuzzifiED.SilentStd","text":"FuzzifiED.SilentStd :: Bool = false\n\na flag to determine whether logs of the FuzzifiED functions should be turned off. False by default. If you want to evaluate without log, put FuzzifiED.SilentStd = true. This parameter can be defined for each process separately. \n\n\n\n\n\n","category":"constant"},{"location":"core/#FuzzifiED.NumThreads","page":"Core functions","title":"FuzzifiED.NumThreads","text":"FuzzifiED.NumThreads :: Int = Threads.nthreads()\n\nan integer to define how many threads OpenMP uses. By default, it is the same as the number of threads in Julia. If you use Jupyter notebooks, which by default uses one core only, you may need to define this by hand, e.g., FuzzifiED.NumThreads = 8. This parameter can be defined for each process separately. \n\n\n\n\n\n","category":"constant"},{"location":"core/#FuzzifiED.Libpath","page":"Core functions","title":"FuzzifiED.Libpath","text":"FuzzifiED.Libpath :: String = FuzzifiED_jll.LibpathFuzzifiED\n\ndefine path of the Fortran library libfuzzified.so. You do not need to modify that by yourself. However, if you compile the Fortran codes by yourself, you need to point this to your compiled library. \n\n\n\n\n\n","category":"constant"},{"location":"core/#FuzzifiED.ElementType","page":"Core functions","title":"FuzzifiED.ElementType","text":"FuzzifiED.ElementType :: DataType = ComplexF64\n\nset the default type of the operator elements, either ComplexF64 or Float64. ComplexF64 by default. \n\n\n\n\n\n","category":"type"},{"location":"core/#FuzzifiED.OpenHelp!-Tuple{}","page":"Core functions","title":"FuzzifiED.OpenHelp!","text":"FuzzifiED.OpenHelp!()\n\nA shortcut to open the link for documentation docs.fuzzified.world in the system browser. \n\n\n\n\n\n","category":"method"},{"location":"core/#Quantum-numbers","page":"Core functions","title":"Quantum numbers","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"FuzzifiED implements diagonal and off-diagonal quantum numbers. They are defined as","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"QNDiag\nQNOffd","category":"page"},{"location":"core/#FuzzifiED.QNDiag","page":"Core functions","title":"FuzzifiED.QNDiag","text":"QNDiag\n\nThe mutable type QNDiag records the information of a diagonal mathrmU(1) or ℤ_p quantum number in the form of a symmetry charge\n\nQ=_o=1^N_oq_on_o\n\nor\n\nQ=_o=1^N_oq_on_o mathrmmod p\n\nwhere i=1N_U is the index of quantum number, o is the index of site, n_o=c^_oc_o, and q_o is a set of coefficients that must be integer valued.\n\nFields\n\nname :: String is the name of the diagonal quantum number \ncharge :: Vector{Int64} is the symmetry charge q_o of each site\nmodul :: Vector{Int64} is the modulus p, set to 1 for mathrmU(1) QNDiags. \n\nInitialisation\n\nIt can be initialised by the following method\n\nQNDiag([name :: String, ]charge :: Vector{Int64}[, modul :: Int64])\n\nThe arguments name and modul are facultative. By default name is set to \"QN\" and modul is set to 1. \n\n\n\n\n\n","category":"type"},{"location":"core/#FuzzifiED.QNOffd","page":"Core functions","title":"FuzzifiED.QNOffd","text":"QNOffd\n\nThe mutable type QNOffd records the information of an off-diagonal ℤ_p quantum number in the form of a discrete transformation\n\n𝒵 c_o α_o^* c^(p_o)_π_o  c_o^ α_o c^(1-p_o)_π_o\n\nwhere we use a notation c^(1)=c^ and c^0=c for convenience, π_o is a permutation of 1N_o, α_o is a coefficient, and p_o specified whether or not particle-hole transformation is performed for the site. Note that one must guarentee that all these transformations commute with each other and also commute with the diagonal QNs. \n\nArguments\n\nperm :: Vector{Int64} is a length-N_o vector that records the permutation π_o.\nph :: Vector{Int64} is a length-N_o vector that records p_o to determine whether or not to perform a particle-hole transformation\nfac :: Vector{ComplexF64} is a length-N_o vector that records the factor α_o in the transformation.\ncyc :: Int64 is the cycle p. \n\nInitialisation\n\nIt can be initialised by the following method\n\nQNOffd(perm :: Vector{Int64}[, ph :: Vector{Int64}][, fac :: Vector{ComplexF64}][, cyc :: Int64])\nQNOffd(perm :: Vector{Int64}, ph_q :: Bool[, fac :: Vector{ComplexF64}])\n\nThe arguments ph, fac and cyc are facultative. By default ph is set all 0, fac is set to all 1 and cyc is set to 2. If ph_q is a bool and true, then ph is set to all 1. \n\n\n\n\n\n","category":"type"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The QNDiag can be added or multiplied by a number ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"+(qnd1 :: QNDiag, qnd2 :: QNDiag)\n*(fac :: Int64, qnd :: QNDiag)","category":"page"},{"location":"core/#Base.:+-Tuple{QNDiag, QNDiag}","page":"Core functions","title":"Base.:+","text":"+(qnd1 :: QNDiag, qnd2 :: QNDiag) :: QNDiag \n-(qnd1 :: QNDiag, qnd2 :: QNDiag) :: QNDiag\n\nreturns the sum or substraction of two QNDiags, whose name is the samea as qnd1, charge is the same as qnd1 ± qnd2, and modulus is the GCD of qnd1 and qnd2. If qnd1 and qnd2 are both ℤ_p quantum numbers and their modulus are coprime, a trivial QNDiag will be returned. \n\n\n\n\n\n","category":"method"},{"location":"core/#Base.:*-Tuple{Int64, QNDiag}","page":"Core functions","title":"Base.:*","text":"*(fac :: Int64, qnd :: QNDiag) :: QNDiag \n*(qnd :: QNDiag, fac :: Int64) :: QNDiag \n÷(qnd :: QNDiag, fac :: Int64) :: QNDiag \n-(qnd :: QNDiag) :: QNDiag\n\nreturns the QNDiag multiplied or divided by an integer factor, where the charge is multiplied or integer-divided by the factor. For ℤ_p quantum numbers, their modulus will be multiplied or integer-divided by the absolute value. If qnd.modul ÷ abs(fac) ≤ 1, a trivial QNDiag will be returned.  \n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The QNOffd can be composed","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"*(qnf1 :: QNOffd, qnf2 :: QNOffd)","category":"page"},{"location":"core/#Base.:*-Tuple{QNOffd, QNOffd}","page":"Core functions","title":"Base.:*","text":"*(qnf1 :: QNOffd, qnf2 :: QNOffd) :: QNOffd\n\nreturns the composition of two QNOffd transformations. The cycle is set to be the LCM of two QNOffds\n\n\n\n\n\n","category":"method"},{"location":"core/#Configurations","page":"Core functions","title":"Configurations","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Confs","category":"page"},{"location":"core/#FuzzifiED.Confs","page":"Core functions","title":"FuzzifiED.Confs","text":"Confs\n\nThe mutable type Confs stores all the configurations that respects the diagonal quantum numbers (QNDiag) and also a table to inversely look up the index from the configuration. \n\nFields\n\nno :: Int64 is the number of sites.\nncf :: Int64 is the number of configurations.\nconf :: Vector{Int64} is an array of length ncf containing all the configurations. Each configuration is expressed in a binary number. If the o-1-th bit of conf[i] is 1, then the o-th site in the i-th configuration is occupied ; if the bit is 0, then the site is empty. \nnor :: Int64, lid :: Vector{Int64} and rid :: Vector{Int64} contain the information of Lin table that is used to inversely look up the index i from the configuration. \n\n\n\n\n\n","category":"type"},{"location":"core/","page":"Core functions","title":"Core functions","text":"It can be generated from the QNDiags.","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Confs(no :: Int64, secd :: Vector{Int64}, qnd :: Vector{QNDiag} ; nor :: Int64 = div(no, 2), num_th :: Int64 = NumThreads, disp_std :: Bool = !SilentStd)","category":"page"},{"location":"core/#FuzzifiED.Confs-Tuple{Int64, Vector{Int64}, Vector{QNDiag}}","page":"Core functions","title":"FuzzifiED.Confs","text":"Confs(no :: Int64, secd :: Vector{Int64}, qnd :: Vector{QNDiag} ; nor :: Int64 = div(no, 2), num_th :: Int64, disp_std :: Bool)\n\ngenerates the configurations from the list of QNDiags. \n\nArguments\n\nno :: Int64 is the number of sites N_o.\nsecd :: Vector{Int64} is the set of Q_i for the selected configurations in the sector.\nqnd :: Vector{QNDiag} is the set of QNDiags. \nnor :: Int64 is the number of less significant bits used to generate the Lin table. Facultative, N_o2 by default.\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\nOutput\n\ncfs :: Confs is a Confs object.\n\nNote\n\nIf your qnd has negative entries, QNDiags must contain the number of electrons.\n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The inverse look-back for a configuration can be done by ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"GetConfId(cfs :: Confs, cf :: Int64)","category":"page"},{"location":"core/#FuzzifiED.GetConfId-Tuple{Confs, Int64}","page":"Core functions","title":"FuzzifiED.GetConfId","text":"GetConfId(cfs :: Confs, cf :: Int64) :: Int64\n\ninversely look up the index from the configuration\n\nArguments\n\ncfs :: Confs stores the configurations.\ncf :: Int64 stores the configuration to be looked-up expressed in a binary number. If the o-1-th bit of conf[i] is 1, then the o-th site in the i-th configuration is occupied ; if the bit is 0, then the site is empty. \n\nOutput\n\nid :: Int64 is the id of the configuration such that cfs.conf[id] == cf\n\n\n\n\n\n","category":"method"},{"location":"core/#Basis","page":"Core functions","title":"Basis","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Basis","category":"page"},{"location":"core/#FuzzifiED.Basis","page":"Core functions","title":"FuzzifiED.Basis","text":"Basis\n\nThe mutable type Basis stores the information of the basis that respects both diagonal and off-diagonal quantum numbers. The states in the basis is in the form \n\nI=λ_i_I1i_I1+λ_i_I2i_I2++λ_i_Im_Ii_Im_I\n\nwhere i is a direct product state, i.e., the configurations i_Ik are grouped into a state I. \n\nFields\n\ncfs :: Confs stores the configurations that respect the QNDiags ;\ndim :: Int64 is the dimension of the basis ;\nszz :: Int64 records the maximum size max m_g of groups;\ncfgr :: Vector{Int64} is a vector of length cfs.ncf and records which group I each configuration i belong to ;\ncffac :: Vector{ComplexF64} is a vector of length cfs.ncf and records the coefficients λ_i of each configuration ;\ngrel :: Matrix{Int64} is a szz*dim matrix that records the configurations in each group i_Ik (k = 1m_I)\ngrsz :: Vector{Int64} is a vector of length dim that records the size m_I of each group.\n\n\n\n\n\n","category":"type"},{"location":"core/","page":"Core functions","title":"Core functions","text":"It can be generated by the following methods.","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Basis(cfs :: Confs, secf :: Vector{ComplexF64}, qnf :: Vector{QNOffd} ; num_th = NumThreads, disp_std = !SilentStd)\nBasis(cfs :: Confs)","category":"page"},{"location":"core/#FuzzifiED.Basis-Tuple{Confs, Vector{ComplexF64}, Vector{QNOffd}}","page":"Core functions","title":"FuzzifiED.Basis","text":"Basis(cfs :: Confs, secf :: Vector{ComplexF64}, qnf :: Vector{QNOffd} ; num_th :: Int64, disp_std :: Bool)\n\ngenerates the basis that respects the off-diagonal ℤ_p quantum numbers (QNOffd)\n\nArguments\n\ncfs :: Confs is the diagonal QN–preserving configurations ;\nsecf :: Vector{ComplexF64} is a vector of length the same as the number of discrete symmetries that records the eigenvalue of each transformation in the sector ;\nqnf :: Vector{QNOffd} is a vector of off-diagonal quantum numbers. \nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\nOutput\n\nbs :: Basis is the resulting Basis object\n\n\n\n\n\n","category":"method"},{"location":"core/#FuzzifiED.Basis-Tuple{Confs}","page":"Core functions","title":"FuzzifiED.Basis","text":"Basis(cfs :: Confs)\n\nGenerate a basis from the configurations without off-diagonal ℤ_n symmetries.\n\nArguments\n\ncfs :: Confs is the diagonal QN–preserving configurations ;\n\nOutput\n\nbs :: Basis is the resulting Basis object\n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The look-back of the weight of a configuration in a state can be done by ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"GetConfWeight(bs :: Basis, st :: Union{Vector{ComplexF64}, Vector{Float64}}, cf :: Int64)","category":"page"},{"location":"core/#FuzzifiED.GetConfWeight-Tuple{Basis, Union{Vector{ComplexF64}, Vector{Float64}}, Int64}","page":"Core functions","title":"FuzzifiED.GetConfWeight","text":"GetConfWeight(bs :: Basis, st :: Vector{<:Number}, cf :: Int64) :: ComplexF64\n\nlooks up a the weight of a configuration in a state. \n\nArguments\n\nbs :: Basis is the basis of the state ; \nst :: Vector{ComplexF64} or st :: Vector{Float64} is a vector of length bs.dim that stores the state ; \ncf :: Int64 stores the configuration to be looked-up expressed in a binary number. If the o-1-th bit of conf[i] is 1, then the o-th site in the i-th configuration is occupied ; if the bit is 0, then the site is empty. \n\nOutput\n\nThe weight of the configuration in the state \n\n\n\n\n\n","category":"method"},{"location":"core/#Term","page":"Core functions","title":"Term","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Term\nTerms","category":"page"},{"location":"core/#FuzzifiED.Term","page":"Core functions","title":"FuzzifiED.Term","text":"Term\n\nThe mutable type Term records a term that looks like Uc^(p_1)_o_1c^(p_2)_o_2 c^(p_l)_o_l in an operator\n\nFields\n\ncoeff :: ComplexF64 records the coefficient U\ncstr :: Vector{Int64} is a length-2l vector (p_1o_1p_2o_2 p_lo_l) recording the operator string\n\nInitialisation\n\nIt can be generated by the function\n\nTerm(coeff :: Number, cstr :: Vector{Int64})\n\n\n\n\n\n","category":"type"},{"location":"core/#FuzzifiED.Terms","page":"Core functions","title":"FuzzifiED.Terms","text":"Terms\n\nTerms is an alias for Vector{Term} for convenience\n\nInitialisation\n\nTerms(coeff :: Number, cstr :: Vector{Int64})\n\nGives a Terms with a single Term.\n\nSpecial elements\n\nThe zero and identity terms are defined \n\nzero(Terms) = Term[]\none(Terms) = Terms(1, [-1, -1])\n\n\n\n\n\n","category":"type"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The product of terms with a number, the sum and product of terms, adjoint and particle-hole transformation are defined","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"*(fac :: Number, tms :: Terms)\n+(tms1 :: Terms, tms2 :: Terms)\n*(tms1 :: Terms, tms2 :: Terms)\nadjoint(tms :: Terms)\nParticleHole(tms :: Terms)","category":"page"},{"location":"core/#Base.:*-Tuple{Number, Vector{Term}}","page":"Core functions","title":"Base.:*","text":"*(fac :: Number, tms :: Terms) :: Terms\n-(tms :: Terms) :: Terms\n*(tms :: Terms, fac :: Number) :: Terms\n/(tms :: Terms, fac :: Number) :: Terms\n\nReturn the product of a collection of terms with a number. \n\n\n\n\n\n","category":"method"},{"location":"core/#Base.:+-Tuple{Vector{Term}, Vector{Term}}","page":"Core functions","title":"Base.:+","text":"+(tms1 :: Terms, tms2 :: Terms) :: Terms\n-(tms1 :: Terms, tms2 :: Terms) :: Terms\n\nReturn the naive sum of two series of terms by taking their union. \n\n\n\n\n\n","category":"method"},{"location":"core/#Base.:*-Tuple{Vector{Term}, Vector{Term}}","page":"Core functions","title":"Base.:*","text":"*(tms1 :: Terms, tms2 :: Terms) :: Terms\n^(tms :: Terms, pow :: Int64) :: Terms\n\nReturn the naive product of two series of terms or the power of one terms. The number of terms equals the product of the number of terms in tms1 and tms2. For each term in tms1 Uc^(p_1)_o_1 and tms2 Uc^(p_1)_o_1, a new term is formed by taking UUc^(p_1)_o_1 c^(p_1)_o_1\n\n\n\n\n\n","category":"method"},{"location":"core/#Base.adjoint-Tuple{Vector{Term}}","page":"Core functions","title":"Base.adjoint","text":"adjoint(tm :: Term) :: Term\nadjoint(tms :: Terms) :: Terms\n\nReturn the Hermitian conjugate of a series of terms. For each term Uc^(p_1)_o_1c^(p_2)_o_2 c^(p_l)_o_l, the adjoint is barUc^(1-p_l)_o_l c^(1-p_2)_o_2c^(1-p_1)_o_1\n\n\n\n\n\n","category":"method"},{"location":"core/#FuzzifiED.ParticleHole-Tuple{Vector{Term}}","page":"Core functions","title":"FuzzifiED.ParticleHole","text":"ParticleHole(tm :: Term) :: Term\nParticleHole(tms :: Terms) :: Terms\n\nReturn the particle-hole transformation of a series of terms. For each term Uc^(p_1)_o_1c^(p_2)_o_2 c^(p_l)_o_l, the transformation results in Uc^(1-p_1)_o_1c^(1-p_2)_o_2c^(1-p_l)_o_l\n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The terms can be simplified by ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"NormalOrder(tm :: Term)\nSimplifyTerms(tms :: Terms)","category":"page"},{"location":"core/#FuzzifiED.NormalOrder-Tuple{Term}","page":"Core functions","title":"FuzzifiED.NormalOrder","text":"NormalOrder(tm :: Term) :: Terms\n\nrearrange a term such that \n\nthe creation operators must be commuted in front of the annihilation operator \nthe site index of the creation operators are in ascending order and the annihilation operators in descending order. \n\nreturn a list of terms whose result is equal to the original term. \n\n\n\n\n\n","category":"method"},{"location":"core/#FuzzifiED.SimplifyTerms-Tuple{Vector{Term}}","page":"Core functions","title":"FuzzifiED.SimplifyTerms","text":"SimplifyTerms(tms :: Terms ; cutoff :: Float64 = eps(Float64)) :: Terms\n\nsimplifies the sum of terms such that \n\neach term is normal ordered,\nlike terms are combined, and terms with zero coefficients are removed.\n\nArgument\n\ncutoff :: Float64 is the cutoff such that terms with smaller absolute value of coefficients will be neglected. Facultative, eps(Float64) by default. \n\n\n\n\n\n","category":"method"},{"location":"core/#Operator","page":"Core functions","title":"Operator","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Operator","category":"page"},{"location":"core/#FuzzifiED.Operator","page":"Core functions","title":"FuzzifiED.Operator","text":"Operator\n\nThe mutable type Operator records the sum of terms together with information about its symmetry and the basis of the state it acts on and the basis of the resulting state.\n\nFields\n\nbsd :: Basis is the basis of the initial state ;\nbsf :: Basis is the basis of the final state ;\nred_q :: Int64 is a flag that records whether or not the conversion to a sparse martrix can be simplified : if bsd and bsf have exactly the same set of quantum numbers, and the operator fully respects the symmetries, and all the elements in bsd.cffac and bsf.cffac has the same absolute value, then red_q = 1 ; otherwise red_q = 0 ; \nsym_q :: Int64 records the symmetry of the operator : if the matrix is Hermitian, then sym_q = 1 ; if it is symmetric, then sym_q = 2 ; otherwise sym_q = 0 ;\nntm :: Int64 is the number of terms ;\nnc :: Int64 is the maximum number of operators in an operator string\ncstrs :: Matrix{Int64} is a matrix recording the operator string of each term. Each column corresponds to a term and is padded to the maximum length with -1's.\ncoeffs :: Vector{ComplexF64} corresponds to the coefficients in each term.\n\n\n\n\n\n","category":"type"},{"location":"core/","page":"Core functions","title":"Core functions","text":"It can be generated by the following methods.","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Operator(bsd :: Basis, bsf :: Basis, terms :: Terms ; red_q :: Int64 = 0, sym_q :: Int64 = 0)","category":"page"},{"location":"core/#FuzzifiED.Operator-Tuple{Basis, Basis, Vector{Term}}","page":"Core functions","title":"FuzzifiED.Operator","text":"Operator(bsd :: Basis[, bsf :: Basis], terms :: Terms ; red_q :: Int64, sym_q :: Int64, num_th :: Int64, disp_std :: Bool) :: Operator\n\ngenerates an operator object from a series of terms. \n\nArguments\n\nbsd :: Basis is the basis of the initial state ;\nbsf :: Basis is the basis of the final state. Facultative, the same as bsd by default. \nterms :: Terms records the terms ; \nred_q :: Int64 is a flag that records whether or not the conversion to a sparse martrix can be simplified : if bsd and bsf have exactly the same set of quantum numbers, and the operator fully respects the symmetries, and all the elements in bsd.cffac and bsf.cffac has the same absolute value, then red_q = 1 ; otherwise red_q = 0 ; Facultative, if bsf is not given, 1 by default, otherwise 0 by default.\nsym_q :: Int64 records the symmetry of the operator : if the matrix is Hermitian, then sym_q = 1 ; if it is symmetric, then sym_q = 2 ; otherwise sym_q = 0. Facultative, if bsf is not given, 1 by default, otherwise 0 by default.\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The product of an operator on a state and the inner product of a final state, an operator and an initial state can be calculated by","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"*(op :: Operator, st_d :: Vector{ComplexF64})\n*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, op :: Operator, st_d :: Vector{ComplexF64})","category":"page"},{"location":"core/#Base.:*-Tuple{Operator, Vector{ComplexF64}}","page":"Core functions","title":"Base.:*","text":"*(op :: Operator, st_d :: Vector{ComplexF64} ; num_th :: Int64, disp_std :: Bool) :: Vector{ComplexF64}\n*(op :: Operator, st_d :: Vector{Float64} ; num_th :: Int64, disp_std :: Bool) :: Vector{Float64}\n\nMeasure the action of an operator on a state. st_d must be of length op.bsd.dim. Returns a vector of length op.bsf.dim that represents the final state.\n\nFacultative arguments\n\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"core/#Base.:*-Tuple{Adjoint{ComplexF64, Vector{ComplexF64}}, Operator, Vector{ComplexF64}}","page":"Core functions","title":"Base.:*","text":"*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, op :: Operator, st_d :: Vector{ComplexF64} ; num_th :: Int64, disp_std :: Bool) :: ComplexF64\n*(st_fp :: LinearAlgebra.Adjoint{Float64, Vector{Float64}}, op :: Operator, st_d :: Vector{Float64} ; num_th :: Int64, disp_std :: Bool) :: Float64\n\nMeasuring the inner product between two states and an operator. st_d must be of length op.bsd.dim and st_fp must be of length op.bsf.dim, and st_fp must be an adjoint. \n\nFacultative arguments\n\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"core/#Sparse-matrix","page":"Core functions","title":"Sparse matrix","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"OpMat{T}","category":"page"},{"location":"core/#FuzzifiED.OpMat","page":"Core functions","title":"FuzzifiED.OpMat","text":"OpMat{ComplexF64}\nOpMat{Float64}\n\nThe mutable type OpMat{T} where the element type T can be Float64 and ComplexF64 stores a sparse matrix in the same form as SparseMatrixCSC in SparseArrays. If the matrix is Hermitian or symmetric, only the lower triangle is stored. \n\nFields\n\ndimd :: Int64 and dimf :: Int64 are the number of columns and rows of the matrix ;\nsymq :: Int64 records whether or not the matrix is Hermitian or symmetric ;\nnel :: Int64 records the number of elements ;\ncolptr :: Vector{Int64}, rowid :: Vector{Int64} and elval :: Vector{ComplexF64} records the elements of the sparse matrix as in the SparseMatrixCSC elements of Julia. \n\n\n\n\n\n","category":"type"},{"location":"core/","page":"Core functions","title":"Core functions","text":"It can be generated by the following methods.","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"OpMat(op :: Operator ; type :: DataType = ElementType)","category":"page"},{"location":"core/#FuzzifiED.OpMat-Tuple{Operator}","page":"Core functions","title":"FuzzifiED.OpMat","text":"OpMat[{type}](op :: Operator ; num_th :: Int64, disp_std :: Bool) :: OpMat{type}\n\nGenerates the sparse matrix from the operator. The parameter type is either Float64 or ComplexF64 ; it is facultative, given by ElementType by default. \n\nArguments\n\nop :: Operator is the operator ;\ntype :: DataType specifies the type of the matrix. It can either be ComplexF64 or Float64. Facultative, the same as ElementType by default\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The lowest eigenstates of the sparse matrix can be calculated by ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"GetEigensystem(mat :: OpMat{ComplexF64}, nst :: Int64 ; tol :: Float64 = 1E-8, ncv :: Int64 = max(2 * nst, nst + 10))","category":"page"},{"location":"core/#FuzzifiED.GetEigensystem-Tuple{OpMat{ComplexF64}, Int64}","page":"Core functions","title":"FuzzifiED.GetEigensystem","text":"GetEigensystem(mat :: OpMat{ComplexF64}, nst :: Int64 ; tol :: Float64, ncv :: Int64, initvec :: Vector{ComplexF64}, num_th :: Int64, disp_std :: Bool) :: Tuple{Vector{ComplexF64}, Matrix{ComplexF64}}\nGetEigensystem(mat :: OpMat{Float64}, nst :: Int64 ; tol :: Float64, ncv :: Int64, initvec :: Vector{Float64}, num_th :: Int64, disp_std :: Bool) :: Tuple{Vector{Float64}, Matrix{Float64}}\n\ncalls the Arpack package to calculate the lowest eigenstates of sparse matrix. \n\nArguments\n\nmat :: OpMat{ComplexF64} or mat :: OpMat{Float64} is the matrix ;\nnst :: Int64 is the number of eigenstates to be calculated ;\ntol :: Float64 is the tolerence for the Arpack process. The default value is 1E-8 ;\nncv :: Int64 is an auxiliary parameter needed in the Arpack process. The default value is max(2 * nst, nst + 10)\ninitvec :: Vector{ComplexF64} or initvec :: Vector{Float64} is the initial vector. If empty, a random initialisation shall be used. Facultative, empty by default. \nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\nOutput\n\nA length-nst array that has the same type as mat recording the eigenvalues, and \nA dimd*nst matrix that has the same type as mat where every column records an eigenstate. \n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The product of an operator on a state and the inner product of a final state, an operator and an initial state can be calculated by","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"*(mat :: OpMat{ComplexF64}, st_d :: Vector{ComplexF64})\n*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, mat :: OpMat{ComplexF64}, st_d :: Vector{ComplexF64})","category":"page"},{"location":"core/#Base.:*-Tuple{OpMat{ComplexF64}, Vector{ComplexF64}}","page":"Core functions","title":"Base.:*","text":"*(mat :: OpMat{ComplexF64}, st_d :: Vector{ComplexF64} ; num_th :: Int64) :: Vector{ComplexF64}\n*(mat :: OpMat{Float64}, st_d :: Vector{Float64} ; num_th :: Int64) :: Vector{Float64}\n\nMeasure the action of a sparse matrix on a state. st_d must be of length mat.dimd. Returns a vector of length mat.dimf that represents the final state. \n\nFacultative argument\n\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \n\n\n\n\n\n","category":"method"},{"location":"core/#Base.:*-Tuple{Adjoint{ComplexF64, Vector{ComplexF64}}, OpMat{ComplexF64}, Vector{ComplexF64}}","page":"Core functions","title":"Base.:*","text":"*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, mat :: OpMat{ComplexF64}, st_d :: Vector{ComplexF64} ; num_th :: Int64) :: ComplexF64\n*(st_fp :: LinearAlgebra.Adjoint{Float64, Vector{Float64}}, mat :: OpMat{Float64}, st_d :: Vector{Float64} ; num_th :: Int64) :: Float64\n\nMeasuring the inner product between two states and a sparse matrix. st_d must be of length mat.dimd and st_fp must be of length mat.dimf, and st_fp must be an adjoint. \n\nFacultative argument\n\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Note that sometimes it is needed to transform a state from one basis to another. This can be done by constructing an identity operator. ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"stf = Operator(bsd, bsf, one(Terms)) * std","category":"page"},{"location":"core/#Entanglement","page":"Core functions","title":"Entanglement","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"StateDecompMat(st :: Vector{<:Number}, bs0 :: Basis, bsa :: Basis, bsb :: Basis, amp_oa :: Vector{<:Number}, amp_ob :: Vector{<:Number})\nGetEntSpec(st :: Vector{<:Number}, bs0 :: Basis, secd_lst :: Vector{Vector{Vector{Int64}}}, secf_lst :: Vector{Vector{Vector{Int64}}} ; qnd_a :: Vector{QNDiag}, qnd_b :: Vector{QNDiag} = qnd_a, qnf_a :: Vector{QNOffd}, qnf_b :: Vector{QNOffd} = qnf_a, amp_oa :: Vector{<:Number}, amp_ob :: Vector{<:Number} = sqrt.(1 .- abs.(amp_oa .^ 2)))","category":"page"},{"location":"core/#FuzzifiED.StateDecompMat-Tuple{Vector{<:Number}, Basis, Basis, Basis, Vector{<:Number}, Vector{<:Number}}","page":"Core functions","title":"FuzzifiED.StateDecompMat","text":"StateDecompMat(st :: Vector{<:Number}, bs0 :: Basis, bsa :: Basis, bsb :: Basis, amp_oa :: Vector{ComplexF64}, amp_ob :: Vector{ComplexF64}) :: Matrix{ComplexF64}\n\nDecompose a state ψ=v_II into a direct-product basis of two subsystems ψ=M_JII_AJ_B\n\nArguments\n\nst :: Vector{<:Number} is the state to be decomposed into direct-product basis of two subsystems.\nbs0 :: Basis is the total basis. \nbsa :: Basis is the basis for the subsystem A.\nbsb :: Basis is the basis for the subsystem B. \namp_oa :: Vector{ComplexF64} is a complex list of length no that specifies the amplitute of each orbital in the subsystem A. For a non-local basis, we decompose each electron into creation operators in two subsystems c^_o=a_oAc^_oA+a_oBc^_oB and this list specifies a_oA. This is equivalent to ℱ_mA in PRB 85, 125308 (2012) with an extra phase factor. \namp_ob :: Vector{ComplexF64} is a complex list of length no that specifies the amplitute of each orbital in the subsystem B. \n\nOutput\n\nA complex matrix of dimension bsb.dim * bsa.dim that corresponds to the state in the decomposed basis ψ=M_JII_AJ_B. This is equivalent to R_μν^Ap in PRB 85, 125308 (2012). After calculating all the sectors, the reduced density matrix will be ρ_B=mathbfMmathbfM^\n\n\n\n\n\n","category":"method"},{"location":"core/#FuzzifiED.GetEntSpec-Tuple{Vector{<:Number}, Basis, Vector{Vector{Vector{Int64}}}, Vector{Vector{Vector{Int64}}}}","page":"Core functions","title":"FuzzifiED.GetEntSpec","text":"GetEntSpec(st :: Vector{<:Number}, bs0 :: Basis, secd_lst :: Vector{Vector{Vector{Int64}}}, secf_lst :: Vector{Vector{Vector{<:Number}}} ; qnd_a :: Vector{QNDiag}, qnd_b :: Vector{QNDiag} = qnd_a, qnf_a :: Vector{QNOffd}, qnf_b :: Vector{QNOffd} = qnf_a, amp_oa :: Vector{<:Number}, amp_ob :: Vector{<:Number} = sqrt.(1 .- abs.(amp_oa .^ 2))) :: Dict{@NamedTuple{secd_a, secf_a, secd_b, secf_b}, Vector{Float64}}\n\nArguments\n\nst :: Vector{<:Number} is the state to be decomposed into direct-product basis of two subsystems.\nbs0 :: Basis is the total basis. \nsecd_lst :: Vector{Vector{Vector{Int64}}} gives the list of QNDiag sectors of subsystems to be calculated. Each of its elements is a two element vector ; the first specifies the sector for subsystem A, and the second specifies the sector for subsystem B. \nsecf_lst :: Vector{Vector{Vector{ComplexF64}}} gives the list of QNOffd sectors of subsystems to be calculated. Each of its elements is a two element vector ; the first specifies the sector for subsystem A, and the second specifies the sector for subsystem B. \nqnd_a :: Vector{QNDiag}, qnd_b :: Vector{QNDiag} = qnd_a, qnf_a :: Vector{QNOffd}, qnf_b :: Vector{QNOffd} specifies the diagonal and off-diagonal quantum numbers of the subsystems A and B. qnd_b and qnf_b are facultative and the same as qnd_a and qnf_a by default. \namp_oa :: Vector{ComplexF64} and amp_ob :: Vector{ComplexF64} are complex lists of length no that specify the amplitute of each orbital in the subsystems A and B. For a non-local basis, we decompose each electron into creation operators in two subsystems c^_o=a_oAc^_oA+a_oBc^_oB and this list specifies a_oA. This is equivalent to ℱ_mA in PRB 85, 125308 (2012) with an extra phase factor. \n\nOutput\n\nA dictionary whose keys are named tuples that specify the sector containing entries secd_a, secf_a, secd_b, secf_b and values are lists of eigenvalues of the density matrix in those sectors. \n\n\n\n\n\n","category":"method"},{"location":"intro/#An-introduction-to-fuzzy-sphere","page":"Introduction","title":"An introduction to fuzzy sphere","text":"","category":"section"},{"location":"intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Conformal field theory (CFT) is one of the central topics of modern physics. It has provided invaluable insights into critical phenomena in condensed matter physics, string theory and AdS/CFT correspondence in quantum gravity, and enhanced our understanding of the renormalisation group and other fundamental structures and dynamics of quantum field theory (QFT). In 2d, many CFTs are well understood thanks to their integratibility. Going to higher dimensions, CFTs are much less well-studied due to a much smaller conformal group. Existing approaches, including Monte Carlo lattice simulation and numerical conformal bootstrap, despite having achieved many successes, can only handle a limited number of CFTs and obtain a limited number of conformal data.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Recently, fuzzy sphere regularisation has emerged as a new powerful method to study 3D CFTs. By studying interacting quantum systems on the fuzzy (non-commutative) sphere, the method realises (2+1)D quantum phase transitions on the geometry S^2timesmathbbR. Compared with conventional methods that involve simulating lattice models, this approach offers distinct advantages including exact preservation of rotation symmetry, direct observation of emergent conformal symmetry, and the efficient extraction of conformal data. In the fuzzy sphere method, the state-operator correspondence plays an essential role. Specifically, there is a one-to-one correspondence between the eigenstates of the critical Hamiltonian on the sphere and the CFT operators, where the energy gaps are proportional to the scaling dimensions. The power of this approach has been demonstrated in the context of the 3D Ising transition, where the presence of emergent conformal symmetry has been convincingly established and a wealth of conformal data has been accurately computed. The study has been extended to the magnetic line defect, various conformal boundaries in 3D Ising CFT, conformal generators, Wilson-Fisher theory, and deconfined criticality. ","category":"page"},{"location":"intro/#Review-of-existing-work","page":"Introduction","title":"Review of existing work","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The study of 3d CFTs on fuzzy sphere can mainly be devided into four catagories :","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Accessing various conformal data, \nRealising various 3d CFTs,\nStudying conformal defects and boundaries, and \nExploring applicable numerical techniques.","category":"page"},{"location":"intro/#Accessing-various-conformal-data","page":"Introduction","title":"Accessing various conformal data","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The first direction is to develop methods to calculate as many data and quantities of 3d CFTs on fuzzy sphere. Typically, these methods are tested on the simplest example of 3d Ising CFT. For many of those CFT data, fuzzy sphere is the first non-perturbative method to access them ; for the others, fuzzy sphere has achieved great consistency with previous methods such as quantum Monte Carlo and conformal bootstrap. So far, the accessible CFT data include operator spectrum, OPE coefficients, correlation functions, entropic F-function and conformal generators. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Operator spectrum [Zhu 2022] This seminal paper opens a new avenue for studying 3d conformal field theories. It calculates and analyses the energy spectra at the 3d Ising transition, and explicitly demonstrate the state-operator correspondence as a fingerprint of conformal field theory, thus directly elucidates the emergent conformal symmetry of the 3d Ising transition.\nOPE coefficients [Hu 2023Mar] This paper computes 17 OPE coefficients of low-lying CFT primary fields with high accuracy, including 4 that has not being reported before.\nCorrelation functions [Han 2023Jun] This paper computes the four-point correlators and verify the crossing symmetry. \nEntropic F-function [Hu 2024] This paper have performed the first non-perturbative computation of the F-function for the paradigmatic 3d Ising conformal field theory through entanglement entropy. \nConformal generators [Fardelli 2024, Fan 2024] These papers investigate the conformal generators of translations and special conformal transformations which are emergent in the infrared and construct these generators using the energy momentum tensor.","category":"page"},{"location":"intro/#Realising-various-3d-CFTs","page":"Introduction","title":"Realising various 3d CFTs","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The second direction is study various other CFTs beyond 3d Ising. Fuzzy sphere has revealed many new information about these theories ; the previously known data are also consistent with fuzzy sphere results. So far, the accessible CFTs include mathrmSO(5) deconfined criticality, mathrmO(3) Wilson-Fisher and a series of new theories with mathrmSp(N) symmetry. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The mathrmSO(5) deconfined criticality [Zhou 2023] This paper provides clear evidence that the DQCP exhibits approximate conformal symmetry, and demonstrate that the DQCP is more likely pseudo-critical.\nThe mathrmO(3) Wilson-Fisher [Han 2023Dec] This paper design a microscopic model of Heisenberg magnet bilayer and study the underlying Wilson-Fisher mathrmO(3) transition through the lens of fuzzy sphere regularization. \nA series of new mathrmSp(N)-symmetric CFTs [Zhou 2024Oct] This paper discovers a series of new CFTs with global symmetry mathrmSp(N) in the fuzzy sphere models that are closely related to the SO(5) deconfined phase transition, and are related to non-linear sigma model with a Wess-Zumino-Witten term and Chern-Simons-matter theories. The emergent conformal symmetry is numerically verified by observing the integer-spaced conformal multiplets and the quality of conformal generators. ","category":"page"},{"location":"intro/#Studying-conformal-defects-and-boundaries","page":"Introduction","title":"Studying conformal defects and boundaries","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Apart from the bulk CFTs, fuzzy sphere can also be used to study their conformal defects and boundaries. So far, the accessible defects/boundaries include the magnetic line defect of 3d Ising CFT, including its defect operator spectrum, correlators, g-function, defect changing operators, and its cusp, and the conformal boundaries of 3d Ising CFT.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Conformal magnetic line defect [Hu 2023Aug] This paper studies the magnetic line defect of 3D Ising CFT and clearly demonstrates that it flows to a conformal defect fixed point. The authors have identified 6 low-lying defect primary operators and extract their scaling dimensions, as well as computing one-point bulk correlators and two-point bulk-defect correlators.\nThe g-function and defect changing operators [Zhou 2024Jan] This paper have performed the non-perturbative computations of the scaling dimensions of defect-changing, creation operators and the g-function for the pinning defect in 3d Ising model. \nCusp [Cuomo 2024] This paper study the general properties of the cusp anomalous dimension and in particular calculates the pinning field defects in the 3d Ising model on fuzzy sphere.\nConformal boundaries of 3d Ising CFT [Zhou 2024Jul, Dedushenko 2024] These papers demonstrates that conformal field theory (CFT) with a boundary, known as surface CFT in three dimensions, can be studied with the setup of fuzzy sphere, and in particular in the example of surface criticality, proposes two schemes by cutting a boundary in the orbital space or the real space to realise the ordinary and the normal surface CFTs on the fuzzy sphere.","category":"page"},{"location":"intro/#Exploring-applicable-numerical-techniques","page":"Introduction","title":"Exploring applicable numerical techniques","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"So far, the numerical methods that has been applied to fuzzy sphere to include exact diagonalisation (ED), density matrix renormalisation group (DMRG) and determinant quantum Monte Carlo (DQMC). The former two has been reviewed in previous sections.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Quantum Monte Carlo on fuzzy sphere [Hofmann 2023] This paper presents a numerical quantum Monte Carlo (QMC) method for simulating the 3D phase transition on the recently proposed fuzzy sphere.","category":"page"},{"location":"intro/#Model-construction","page":"Introduction","title":"Model construction","text":"","category":"section"},{"location":"intro/#Projection-onto-the-lowest-Landau-level","page":"Introduction","title":"Projection onto the lowest Landau level","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"To build the setup of fuzzy sphere, we consider a sphere with radius R and put a 4pi s-monopole at its centre. Consider free electrons moving on the sphere. The monopole will modify the single particle Hamilltonian. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    H_0=frac12MR^2(partial^mu+iA^mu)^2","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where mu=thetaphi and we take ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    A_theta=0 A_phi=-fracsRoperatornamectgtheta","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The eigenstates of the Hamiltonian are the monopole spherical harmonics","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Y_lm^(s)(hatmathbfr)quad l=ss+1dotsquad m=-sdotss-1s","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"with the eigenenergies ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    E_l=frac12MR^2(l(l+1)-s^2)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Each level, known as a Landau level, has a degeneracy of (2l+1). Specifically, the wavefunctions on the lowest Landau level (LLL) l=s is easy to write out :","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Y_sm^(s)(hatmathbfr)=C_me^imphicos^s+mfractheta2sin^s-mfractheta2quad C_m=frac1sqrt4piBeta(s+m+1s-m+1)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where C_m is the normalising factor. The LLL has a degeneracy N_m=2s+1","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We now consider N_f flavours of fermions moving on the sphere, characterised by the second-quantised fermion operator hatpsi_f(hatmathbfr), with a flavour index f=1dotsN_f. We partially fill the lowest Landau level and set the single energy gap to be much larger than the scale of interaction H_0gg H_mathrmint, so that the quantum fluctuation can be constrained on the lowest Landau level. In practice, we often fill integer number of flavours N_e=kN_m (kinmathbbZ) so that a quantum Hall ferromagnet (i.e., the state where integer number of LLLs are filled) can exist on the phase diagram. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We then project the system onto the LLL. Technically, this can be done by write the fermion operators in terms of the annihilation operators of the LLL orbitals","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    hatpsi_f(hatmathbfr)=sum_m=-s^s Y^(s)_sm(hatmathbfr)hatc_mf","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where hatc^(dagger)_mf annihilates/creates an electron with L^z-quantum number m at the f-th flavour of the lowest Landau level. In the following sections, we will omit the hats on the operators.","category":"page"},{"location":"intro/#Density-operator","page":"Introduction","title":"Density operator","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The simplest building block of an interacting many-body Hamiltonian is density operators, which are local fermion bilinears. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    n_M(hatmathbfr)=psi_f^dagger(hatmathbfr)M_ffpsi_f(hatmathbfr)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Here the matrix insertion M put the density operators at a certain representation of the flavour symmetry. Like the fermion operator, the density operator can also be expressed in the orbital space. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    n_M(hatmathbfr)=sum_lmY_lm(hatmathbfr)n_lm","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Conversely,","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    beginaligned\n        n_lm=intmathrmd^2hatmathbfrbarY_lmn_M(hatmathbfr)\n        =intmathrmd^2hatmathbfrbarY_lmleft(sum_m_1barY^(s)_sm_1c^dagger_m_1f_1right)M_f_1f_2left(sum_m_2Y^(s)_sm_2c_m_1f_2right)\n        =sum_m_1m_2c^dagger_m_1f_1M_f_1f_2c_m_1f_2intmathrmd^2hatmathbfrbarY_lmbarY^(s)_sm_1Y^(s)_sm_2\n        =sum_m_1c^dagger_m_1f_1M_f_1f_2c_m+m_1f_2(-1)^s+m+m_1(2s+1)sqrtfrac2l+14pibeginpmatrixslsm_1m-m_1-mendpmatrixbeginpmatrixslsm_1m-m_1-mendpmatrix\n    endaligned","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where various properties of the monopole spherical harmonics are used. In this way, we have fully expressed the density operator in terms of the operators in the orbital space c^(dagger)_mf. ","category":"page"},{"location":"intro/#Density-density-interaction","page":"Introduction","title":"Density-density interaction","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The most straightforward way to construct an interaction term is to add a density-density interaction potential U(r). We note that this is not the simplest construction and we will present the simpler construction in terms of pseudopotentials in the next section. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    H_mathrmint=intmathrmd^2hatmathbfr_1mathrmd^2hatmathbfr_2U(hatmathbfr_1-hatmathbfr_2)n_M(hatmathbfr_1)n_M(hatmathbfr_2)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The interacting potentials can be expanded in terms of the Legendre polynomials ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    U(theta_12)=sum_lU_lP_l(costheta_12)=sum_lmfrac4pi2l+1barY_lm(hatmathbfr_1)Y_lm(hatmathbfr_2)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Conversely","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    U_l=int sintheta_12mathrmdtheta_12frac2l+12U(theta_12)P_l(costheta_12)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Specifically, for local and super-local interactions","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    beginaligned\n        U(mathbfr_12)=delta(mathbfr_12)U_l=2l+1\n        U(mathbfr_12)=nabla^2delta(mathbfr_12)U_l=-l(l+1)(2l+1)\n    endaligned","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"By expanding the density operators into the orbital space and completing the integrals,","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    H_mathrmint=sum_lmfrac4pi U_l2l+1n^dagger_Mlmn_Mlm","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"For example, for the 3d Ising CFT, we take two flavours of fermions and write down an interaction ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    H_mathrmint=intmathrmd^2hatmathbfr_1mathrmd^2hatmathbfr_2U(hatmathbfr_1-hatmathbfr_2)(n_0(hatmathbfr_1)n_0(hatmathbfr_2)-n_z(hatmathbfr_1)n_z(hatmathbfr_2))-hintmathrmd^2hatmathbfrn_x(hatmathbfr)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where the density operators are defined as ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    n_i(hatmathbfr)=psi^dagger_f(hatmathbfr)(sigma_i)_ffpsi_f(hatmathbfr)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"and the potentials are taken as a combination of local and super-local interactions.","category":"page"},{"location":"intro/#Interaction-in-terms-of-pseudopotentials","page":"Introduction","title":"Interaction in terms of pseudopotentials","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Another way that is much more convenient to construct the interactions is through Haldane pseudopotential. To explain the idea, we take the 3d Ising model as an example. We first classify all the fermion bilinears lambda_mmffc_mfc_mf. To simplify the discussion, we can take a specific pseudo-spin index lambda_mmc_muparrowc_mdownarrow. The fermion bilinears can be classified into irreducible representations of mathrmSO(3) rotation symmetry. Since c_mf carries the spin-s representation, the spin of its bilinear ranges from 0 to 2s and takes integer values. The spin-(2s-l) combination reads","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Delta_lm=sqrt2s-2l+1sum_m_1beginpmatrixss2s-lm_1m-m_1-mendpmatrixc_m_1uparrowc_m-m_1downarrow","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where m=-(2s-l)dots(2s-l). A four-fermion interaction term can be formed by contracting these paring operators with its conjugate. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    H=sum_lU_lH_lquad H_l=sum_mDelta_lm^daggerDelta_lm","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The coupling strength U_l of the spin-(2s-l) channel is called the Haldane pseudopotentials. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We need also to consider the constraint that the two fermions must be anti-symmetrised : for even l, the orbital index is symmetrised, so the spin index must be antisymmetrised, so the two fermions form a spin-singlet which is invariant under the mathrmSU(2) transformation ; for odd l, the orbital index is anti-symmetrised, so the spin index is symmetrised, breaking the flavour symmetry from mathrmSU(2) to mathbbZ_2. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The fermion bilinears with other pseudo-spin configurations lambda_mmpm(c_muparrowc_muparrowpm c_mdownarrowc_mdownarrow) can be analysed in a similar way. After that, we have enumerated all possible four-fermion interaction terms. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"For systems with more complicated continuous symmetries, classification in terms of representation of flavour symmetry must also be considered, and the indices must be overall antisymmetrised. For an example with mathrmSp(N) symmetry, see Zhou 2024Oct.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We also note that each pseudopotential can correspond to a profile of interaction potential functions. Specifically, U_0 corresponds to a local interaction ; U_l corresponds to a super-local interaction nabla^2ldelta(mathbfr_12) in the thermodynamic limit. For a more detailed expression at finite system size, see Fan 2024.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"One can keep only terms with the smallest l. For Ising model, we can keep up to l=1. Note that at lease one term with odd l must be kept to break the mathrmSU(2) symmetry. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    H=U_0sum_mDelta_0m^daggerDelta_0m+U_1sum_mDelta_1m^daggerDelta_1m-hn_x00","category":"page"},{"location":"intro/#Local-observables","page":"Introduction","title":"Local observables","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"On the fuzzy sphere, the simplest local observable is the density operator. We consider the Ising model as an example specifically","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    n^i(Omega)=Psi^dagger(Omega)sigma^iPsi(Omega)=sum_mmY^(s)_sm(Omega)barY^(s)_sm(Omega)mathbfc^dagger_msigma^imathbfc_m","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where i=xz. From the CFT perspective, the density operators are the superpositions of scaling operators with corresponding quantum numbers. In the leading order, they can be used as UV realisations of CFT operators sigma and epsilon.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"beginaligned\n    n^x=lambda_0+lambda_epsilon R^-Delta_epsilonepsilon+lambda_partial_tauepsilonR^-Delta_epsilon-1partial_tauepsilon+lambda_T_tautauR^-3T_tautau+dotsepsilon_mathrmFS=fracn^x-lambda_0lambda_epsilon R^-Delta_epsilonnonumber\n    n^z=lambda_sigma R^-Delta_sigmasigma+lambda_partial_tausigmaR^-Delta_sigma-1partial_tauepsilon+lambda_partial^2sigmaR^-Delta_sigma-2partial^2sigma+dotssigma_mathrmFS=fracn^zlambda_sigma R^-Delta_sigma\nendaligned","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The UV-dependent coefficients lambda_0lambda_sigmalambda_epsilon can be computed from the 1-point function. The subleading terms to the density operators contribute to the finite size corrections","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"beginaligned\n    epsilon_mathrmFS=epsilon+fraclambda_partial_tauepsilonlambda_epsilonR^-1partial_tauepsilon+fraclambda_T_tautaulambda_epsilonR^-3+Delta_epsilonT_tautau+dotsnonumber\n    sigma_mathrmFS=sigma+fraclambda_partial_tausigmalambda_sigmaR^-1partial_tausigma+fraclambda_partial^2sigmalambda_sigmaR^-2partial^2sigma+dots\nendaligned","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where R=N^12 in the fuzzy sphere. ","category":"page"},{"location":"intro/#Conformal-generators","page":"Introduction","title":"Conformal generators","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The conformal generator Lambda^mu=P^mu+K^mu on the states is the l=1 component of the Hamiltonian density. For example, for Ising model, it is the local density operator and density-density interactions with some full derivatives","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    mathscrH(mathbfr)=n_zleft(g_0+g_1nabla^2right)n_z-hn_x+g_D1nabla^2n_x+g_D2nabla^2n_z^2+dots","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where g_Di are undetermined constants that does not affect the Hamiltonian H=intmathrmd^2mathbfrmathscrH. We have only listed a few examples of the allowed full derivatives. The generator is expressed as ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Lambda_m=P_m+K_m=intmathrmd^2mathbfrY_l=1m(mathbfr)mathscrH(mathbfr)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"To determine those constants, we consider another strategy by combining four fermion operators into mathrmSO(3) spin-1 operators. Similar to what we have done for Hamiltonian, we combine the fermion bilinears Delta_lm.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Lambda_m=sum_substackl_1l_2m_1m_2tildeU_l_1l_2Delta^dagger_l_1m_1Delta_l_2m_2beginpmatrix\n        2s-l_12s-l_21-m_1m_2m\n    endpmatrix+hn_x1m","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"For l_1in2mathbbZ, the spin index in the pairing operator is anti-symmetrised ; For l_1in2mathbbZ+1, the spin index in the pairing operator is symmetrised. Therefore, l_1-l_2in2mathbbZ for non-zero results. And since l_1-l_2leq 1, we conclude l_1=l_2, so","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Lambda_m=sum_substacklm_1m_2tildeU_lDelta^dagger_lm_1Delta_lm_2beginpmatrix\n        2s-l2s-l1-m_1m_2m\n    endpmatrix+hn_x1m","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Here, tildeU_l are tuning parameters. ","category":"page"},{"location":"intro/#Numerical-methods","page":"Introduction","title":"Numerical methods","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"(under construction)","category":"page"},{"location":"intro/#Exact-diagonalisation","page":"Introduction","title":"Exact diagonalisation","text":"","category":"section"},{"location":"intro/#Density-matrix-renormalisation-group","page":"Introduction","title":"Density matrix renormalisation group","text":"","category":"section"},{"location":"intro/#Determinant-quantum-Monte-Carlo","page":"Introduction","title":"Determinant quantum Monte Carlo","text":"","category":"section"},{"location":"intro/#References","page":"Introduction","title":"References","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Zhu 2022] Uncovering Conformal Symmetry in the 3D Ising Transition: State-Operator Correspondence from a Quantum Fuzzy Sphere Regularization, Wei Zhu, Chao Han, Emilie Huffman, Johannes S. Hofmann, and Yin-Chen He, arXiv:2210.13482, Phys. Rev. X 13, 021009 (2023).\n[Hu 2023Mar] Operator Product Expansion Coefficients of the 3D Ising Criticality via Quantum Fuzzy Sphere, Liangdong Hu, Yin-Chen He, and Wei Zhu, arXiv:2303.08844, Phys. Rev. Lett 131, 031601 (2023).\n[Han 2023Jun] Conformal four-point correlators of the 3D Ising transition via the quantum fuzzy sphere, Chao Han, Liangdong Hu, Wei Zhu, and Yin-Chen He, arXiv:2306.04681, Phys. Rev. B 108, 235123 (2023).\n[Zhou 2023] The mathrmSO(5) Deconfined Phase Transition under the Fuzzy Sphere Microscope: Approximate Conformal Symmetry, Pseudo-Criticality, and Operator Spectrum, Zheng Zhou, Liangdong Hu, Wei Zhu, and Yin-Chen He, arXiv:2306.16435, Phys. Rev. X 14, 021044 (2024).\n[Hu 2023Aug] Solving Conformal Defects in 3D Conformal Field Theory using Fuzzy Sphere Regularization, Liangdong Hu, Yin-Chen He, and Wei Zhu, arXiv:2308.01903, Nat. Commun. 15, 3659 (2024).\n[Hofmann 2024] Quantum Monte Carlo Simulation of the 3D Ising Transition on the Fuzzy Sphere, Johannes S. Hofmann, Florian Goth, Wei Zhu, Yin-Chen He, and Emilie Huffman, arXiv:2310.19880, SciPost Phys. Core 7, 028 (2024).\n[Han 2023Dec] Conformal Operator Content of the Wilson-Fisher Transition on Fuzzy Sphere Bilayers, Chao Han, Liangdong Hu, and Wei Zhu, arXiv:2312.04047, Phys. Rev. B 110, 115113 (2024).\n[Zhou 2024Jan] The g-function and Defect Changing Operators from Wavefunction Overlap on a Fuzzy Sphere, Zheng Zhou, Davide Gaiotto, Yin-Chen He, Yijian Zou, arXiv:2401.00039, SciPost Phys. 17, 021 (2024).\n[Hu 2024] Entropic F-function of 3D Ising conformal field theory via the fuzzy sphere regularization, Liangdong Hu, Wei Zhu, and Yin-Chen He, arXiv:2401.17362.\n[Cuomo 2024] Impurities with a cusp: general theory and 3d Ising, Gabriel Cuomo, Yin-Chen He, Zohar Komargodski, arXiv:2406.10186. \n[Zhou 2024Jul] Studying the 3d Ising surface CFTs on the fuzzy sphere, Zheng Zhou, and Yijian Zou, arXiv:2407.15914.\n[Dedushenko 2024] Ising BCFTs from the fuzzy hemisphere, Mykola Dedushenko, arXiv:2407.15948.\n[Fardelli 2024] Constructing the Infrared Conformal Generators on the Fuzzy Sphere, Giulia Fardelli, A. Liam Fitzpatrick, and Emanuel Katz, arXiv:2409.02998.\n[Fan 2024] Note on explicit construction of conformal generators on the fuzzy sphere, Ruihua Fan, arXiv:2409.08257.\n[Zhou 2024Oct] A new series of 3D CFTs with mathrmSp(N) global symmetry on fuzzy sphere, Zheng Zhou, and Yin-Chen He, arXiv:2410.00087.\n[Voinea 2024] Regularizing 3D conformal field theories via anyons on the fuzzy sphere, arXiv:2411.15299.","category":"page"},{"location":"models/#Built-in-models","page":"Built-in models","title":"Built-in models","text":"","category":"section"},{"location":"models/#Diagonal-quantum-numbers-on-fuzzy-sphere","page":"Built-in models","title":"Diagonal quantum numbers on fuzzy sphere","text":"","category":"section"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"The following diagonal quantum numbers (symmetry charges) on fuzzy sphere are built in in FuzzifiED.","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"GetNeQNDiag(no :: Int64)\nGetLz2QNDiag(nm :: Int64, nf :: Int64)\nGetFlavQNDiag(nm :: Int64, nf :: Int64, qf :: Union{Dict{Int64, Int64}, Vector{Int64}}, id :: Int64 = 1, modul :: Int64 = 1)\nGetZnfChargeQNDiag(nm :: Int64, nf :: Int64)\nGetPinOrbQNDiag(no :: Int64, pin_o :: Vector{Int64}, id :: Int64 = 1) ","category":"page"},{"location":"models/#FuzzifiED.GetNeQNDiag-Tuple{Int64}","page":"Built-in models","title":"FuzzifiED.GetNeQNDiag","text":"GetNeQNDiag(no :: Int64) :: QNDiag\n\nReturn the QNDiag of the number of electrons, implemented as \n\nQNDiag(\"Ne\", fill(1, no))\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetLz2QNDiag-Tuple{Int64, Int64}","page":"Built-in models","title":"FuzzifiED.GetLz2QNDiag","text":"GetLz2QNDiag(nm :: Int64, nf :: Int64) :: QNDiag\n\nReturn the QNDiag of the number of twice the angular momentum 2L_z, implemented as \n\nQNDiag(\"Lz\", collect(0 : nm * nf - 1) .÷ nf .* 2 .- (nm - 1))\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetFlavQNDiag","page":"Built-in models","title":"FuzzifiED.GetFlavQNDiag","text":"GetFlavQNDiag(nm :: Int64, nf :: Int64, qf :: Dict{Int64, Int64}[, id :: Int64 = 1, modul :: Int64 = 1]) :: QNDiag \nGetFlavQNDiag(nm :: Int64, nf :: Int64, qf :: Vector{Int64}[, id :: Int64 = 1, modul :: Int64 = 1]) :: QNDiag\n\nReturn the QNDiag of linear combination of number of electrons in each flavour, \n\n    Q = _fq_fn_f\n\nthe factor q_f can either be given by a length-N_f vector or a dictionary containing non-zero terms. E.g., for Q=n_f=1-n_f=3 in a 4-flavour system, qf = [1, 0, -1, 0] or qf = Dict(1 => 1, 3 => -3). id is an index to be put in the name to distinguish. For qf given as vector, the function is implemented as \n\nQNDiag(\"Sz$id\", qf[collect(0 : nm * nf - 1) .% nf .+ 1], modul)\n\n\n\n\n\n","category":"function"},{"location":"models/#FuzzifiED.GetZnfChargeQNDiag-Tuple{Int64, Int64}","page":"Built-in models","title":"FuzzifiED.GetZnfChargeQNDiag","text":"GetZnfChargeQNDiag(nm :: Int64, nf :: Int64) :: QNDiag\n\nReturn the QNDiag of a ℤ_N_f-charge, \n\n    Q = _f=0^N_f-1fn_f mathrmmod N_f\n\nimplemented as \n\nQNDiag(\"Q_Z$nf\", collect(0 : nm * nf - 1) .% nf, nf)\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetPinOrbQNDiag","page":"Built-in models","title":"FuzzifiED.GetPinOrbQNDiag","text":"GetPinOrbQNDiag(no :: Int64, pin_o :: Vector{Int64}[, id :: Int64 = 1]) :: QNDiag\n\nReturn the QNDiag of the number of electrons in the subset pin_o, implemented as\n\nQNDiag(\"Npin$i\", [ o in pin_o ? 1 : 0 for o = 1 : no])\n\nThis QNDiag is useful in pinning defects, where certain subset of sites need to be set empty or filled. To empty the sites, set this QNDiag to 0 ; to fill the sites, set this QNDiag to length(pin_o). id is an index to be put in the name to distinguish. \n\n\n\n\n\n","category":"function"},{"location":"models/#Off-diagonal-quantum-numbers-on-fuzzy-sphere","page":"Built-in models","title":"Off-diagonal quantum numbers on fuzzy sphere","text":"","category":"section"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"The following off-diagonal quantum numbers (transformations) on fuzzy sphere are built in in FuzzifiED.","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"GetParityQNOffd(nm :: Int64, nf :: Int64, permf :: Union{Dict{Int64, Int64}, Vector{Vector{Int64}}, Vector{Int64}} = Dict{Int64, Int64}(), fac :: Union{Dict{Int64, <: Number}, Vector{<: Number}} = Dict{Int64, ComplexF64}()) \nGetFlavPermQNOffd(nm :: Int64, nf :: Int64, permf :: Union{Dict{Int64, Int64}, Vector{Vector{Int64}}, Vector{Int64}}, fac :: Union{Dict{Int64, <: Number}, Vector{<: Number}} = Dict{Int64, ComplexF64}())\nGetRotyQNOffd(nm :: Int64, nf :: Int64)","category":"page"},{"location":"models/#FuzzifiED.GetParityQNOffd","page":"Built-in models","title":"FuzzifiED.GetParityQNOffd","text":"GetParityQNOffd(nm :: Int64, nf :: Int64[, permf, fac])\n\nReturn the particle-hole transformation \n\n    𝒫 c^_mfα_fc_mπ_f\n\nArguments\n\nnm :: Int64 and nf :: Int64 are the number of orbitals and the flavours.\npermf :: Dict{Int64, Int64}, permf :: Vector{Vector{Int64}} or Vector{Int64} gives the flavour permutation π_f. It is either a vector of the cycles, a vector of the target flavours, or a dictionary of the changed elements. E.g., a permutation 142533415662 can be expressed as [4,5,3,1,6,2], [[1,4],[2,5,6]] or Dict(1=>4,2=>5,4=>1,5=>6,6=>2). Facultative, identity by default. \nfac :: Dict{Int64, <: Number} or Vector{<: Number} gives the factor α_f. It is either a vector of all vectors, or a dictionary of all non-unity elements. Facultative, all unity by default. \n\n\n\n\n\n","category":"function"},{"location":"models/#FuzzifiED.GetFlavPermQNOffd","page":"Built-in models","title":"FuzzifiED.GetFlavPermQNOffd","text":"GetFlavPermQNOffd(nm :: Int64, nf :: Int64, permf , fac][, cyc])\n\nReturn the flavour permutaiton transformation \n\n    𝒵 c^_mfα_fc^_mπ_f\n\nArguments\n\nnm :: Int64 and nf :: Int64 are the number of orbitals and the flavours.\npermf :: Dict{Int64, Int64}, permf :: Vector{Vector{Int64}} or Vector{Int64} gives the flavour permutation π_f. It is either a vector of the cycles, a vector of the target flavours, or a dictionary of the changed elements. E.g., a permutation 142533415662 can be expressed as [4,5,3,1,6,2], [[1,4],[2,5,6]] or Dict(1=>4,2=>5,4=>1,5=>6,6=>2). Facultative, identity by default. \nfac :: Dict{Int64, <: Number} or Vector{<: Number} gives the factor α_f. It is either a vector of all vectors, or a dictionary of all non-unity elements. Facultative, all unity by default. \ncyc :: Int64 is the period of the permutation. \n\n\n\n\n\n","category":"function"},{"location":"models/#FuzzifiED.GetRotyQNOffd-Tuple{Int64, Int64}","page":"Built-in models","title":"FuzzifiED.GetRotyQNOffd","text":"GetRotyQNOffd(nm :: Int64, nf :: Int64)\n\nReturn the π-rotation along the y-axis. \n\n    ℛ_y c^_mf(-)^m+sc^_-mf\n\n\n\n\n\n","category":"method"},{"location":"models/#Operators-on-fuzzy-sphere","page":"Built-in models","title":"Operators on fuzzy sphere","text":"","category":"section"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"GetIntMatrix(nm :: Int64, ps_pot :: Vector{<:Number})\nGetDenIntTerms(nm :: Int64, nf :: Int64, ps_pot :: Vector{<:Number}, mat_a :: Matrix{<:Number} = Matrix{Float64}(I, nf, nf), mat_b :: Matrix{<:Number} = Matrix(mat_a'))\nGetDenIntTerms(nm :: Int64, nf :: Int64, ps_pot :: Vector{<:Number}, mats_a :: Vector{<:AbstractMatrix{<:Number}}, mats_b :: Vector{<:AbstractMatrix{<:Number}} = [Matrix(mat_a') for mat_a in mats_a])\nGetPairIntTerms(nm :: Int64, nf :: Int64, ps_pot :: Vector{<:Number}, mat_a :: Matrix{<:Number}, mat_b :: Matrix{<:Number} = Matrix(mat_a'))\nGetPolTerms(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number})\nGetL2Terms(nm :: Int64, nf :: Int64)\nGetC2Terms(nm :: Int64, nf :: Int64, mat_gen :: Vector{<:AbstractMatrix{<:Number}})","category":"page"},{"location":"models/#FuzzifiED.GetIntMatrix-Tuple{Int64, Vector{<:Number}}","page":"Built-in models","title":"FuzzifiED.GetIntMatrix","text":"GetIntMatrix(nm :: Int64, ps_pot :: Vector{<:Number}) :: Array{ComplexF64, 3}\n\nArgument\n\nnm :: Int64 is the number of orbitals\nps_pot :: Vector{<:Number} is the vector of non-zero pseudopotentials \n\nOutput\n\nA nm*nm*nm array giving the interaction matrix U_m_1m_2m_3-m_1-m_2-m_3\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetDenIntTerms","page":"Built-in models","title":"FuzzifiED.GetDenIntTerms","text":"GetDenIntTerms(nm :: Int64, nf :: Int64[, ps_pot :: Vector{<:Number}][, mat_a :: Matrix{<:Number}[, mat_b :: Matrix{<:Number}]][ ; m_kept :: Vector{Int64}]) :: Terms\n\nReturn the normal-ordered density-density term in the Hamiltonian \n\n_m_if_iU_m_1m_2m_3m_4M^A_f_1f_4M^B_f_2f_3c^_m_1f_1c^_m_2f_2c_m_3f_3c_m_4f_4\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\nps_pot :: Vector{<:Number} is a list of numbers specifying the pseudopotentials for the interacting matrix U_m_1m_2m_3m_4. Facultative, [1.0] by default. \nmat_a :: Matrix{<:Number} is a nf*nf matrix specifying M^A_ff. Facultative, I_N_f by default. \nmat_b :: Matrix{<:Number} is a nf*nf matrix specifying M^B_ff. Facultative, the Hermitian conjugate of mat_a by default. \nm_kept :: Vector{Int64} is a list of orbitals that range from 1 to nm. Facultative, if specified, only terms for which all m_i are in the list are kept. \n\n\n\n\n\n","category":"function"},{"location":"models/#FuzzifiED.GetDenIntTerms-2","page":"Built-in models","title":"FuzzifiED.GetDenIntTerms","text":"GetDenIntTerms(nm :: Int64, nf :: Int64, ps_pot :: Vector{<:Number}, mat_a :: Vector{<:AbstractMatrix{<:Number}}[, mat_b :: Vector{<:AbstractMatrix{<:Number}}][ ; m_kept :: Vector{Int64}]) :: Terms\n\nReturn the sum of a series of normal-ordered density-density term in the Hamiltonian \n\n_m_if_iαU_m_1m_2m_3m_4(M^A_α)_f_1f_4(M^B_α)_f_2f_3c^_m_1f_1c^_m_2f_2c_m_3f_3c_m_4f_4\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\nps_pot :: Vector{<:Number} is a list of numbers specifying the pseudopotentials for the interacting matrix U_m_1m_2m_3m_4. Facultative, [1.0] by default.\nmat_a :: Vector{<:AbstractMatrix{<:Number}} is a vector of nf*nf matrix specifying (M^A_α)_ff. Facultative, I_N_f by default. \nmat_b :: Vector{<:AbstractMatrix{<:Number}} is a vector of nf*nf matrix specifying (M^B_α)_ff. Facultative, the Hermitian conjugate of mat_a by default. \nm_kept :: Vector{Int64} is a list of orbitals that range from 1 to nm. Facultative, if specified, only terms for which all m_i are in the list are kept. \n\n\n\n\n\n","category":"function"},{"location":"models/#FuzzifiED.GetPairIntTerms","page":"Built-in models","title":"FuzzifiED.GetPairIntTerms","text":"GetPairIntTerms(nm :: Int64, nf :: Int64, ps_pot :: Vector{<:Number}, mat_a :: Matrix{<:Number}[, mat_b :: Matrix{<:Number}][ ; m_kept :: Vector{Int64}]) :: Terms\n\nReturn the normal-ordered pair-pair interaction term in the Hamiltonian \n\n_m_if_iU_m_1m_2m_3m_4M^A_f_1f_2M^B_f_3f_4c^_m_1f_1c^_m_2f_2c_m_3f_3c_m_4f_4\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\nps_pot :: Vector{<:Number} is a list of numbers specifying the pseudopotentials for the interacting matrix U_m_1m_2m_3m_4. \nmat_a :: Matrix{<:Number} is a nf*nf matrix specifying M^A_ff. Facultative, I_N_f by default. \nmat_b :: Matrix{<:Number} is a nf*nf matrix specifying M^B_ff. Facultative, the Hermitian conjugate of mat_a by default. \nm_kept :: Vector{Int64} is a list of orbitals that range from 1 to nm. Facultative, if specified, only terms for which all m_i are in the list are kept. \n\n\n\n\n\n","category":"function"},{"location":"models/#FuzzifiED.GetPolTerms-Tuple{Int64, Int64, Matrix{<:Number}}","page":"Built-in models","title":"FuzzifiED.GetPolTerms","text":"GetPolTerms(nm :: Int64, nf :: Int64[, mat :: Matrix{<:Number}][ ; fld_m :: Vector{<:Number}]) :: Terms\n\nReturn the polarisation term in the Hamiltonian \n\n_mffc^_mfM_ffc_mf\n\nArguments\n\nnm :: Int64 is the number of orbitals ;\nnf :: Int64 is the number of flavours ; \nmat :: Matrix{<:Number} is a nf*nf matrix specifying M_ff. Facultative, I_N_f by default. \nfld_m :: Vector{<:Number} gives an orbital dependent polarisation\n\n_mffh_mc^_mfM_ffc_mf\n\nFacultative. \n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetL2Terms-Tuple{Int64, Int64}","page":"Built-in models","title":"FuzzifiED.GetL2Terms","text":"GetL2Terms(nm :: Int64, nf :: Int64) :: Terms\n\nReturn the terms for the total angular momentum.\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetC2Terms-Tuple{Int64, Int64, Vector{<:AbstractMatrix{<:Number}}}","page":"Built-in models","title":"FuzzifiED.GetC2Terms","text":"GetC2Terms(nm :: Int64, nf :: Int64, mat_gen :: Vector{<:AbstractMatrix{<:Number}}[, mat_tr :: Vector{<:AbstractMatrix{<:Number}}]) :: Terms\n\nReturn the terms for the quadratic Casimir of the flavour symmetry.\n\n    C_2=_immfrac(c^_mf_1G_if_1f_2c_mf_2)(c^_mf_3G^_if_3f_4c_mf_4)operatornametrG_i^G_i-_immfrac(c^_mf_1T_if_1f_2c_mf_2)(c^_mf_3T^_if_3f_4c_mf_4)operatornametrT_i^T_i\n\nwhere G_i are the generator matrices, and T_i are the trace matrices. \n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\nmat_gen :: Vector{Matrix{Number}}) is a list of the matrices that gives the generators. It will automatically be normalised such that its square traces to unity. \nmat_tr :: Vector{Matrix{Number}}) is a list of trace matrices that will be normalised automatically and substracted. Facultative.\n\n\n\n\n\n","category":"method"},{"location":"models/#Spherical-observables","page":"Built-in models","title":"Spherical observables","text":"","category":"section"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"FuzzifiED supports local observables on sphere that can be decomposed into angular components Phi(Omega)=sum_lmPhi_lmY^(s)_lm","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"SphereObs","category":"page"},{"location":"models/#FuzzifiED.SphereObs","page":"Built-in models","title":"FuzzifiED.SphereObs","text":"SphereObs\n\nThe mutable type SphereObs stores the information of a local observable (or local operator) Phi that can be decomposed into angular components.\n\n    Phi(Omega)=_lmPhi_lmY^(s)_lm\n\nFields\n\ns2 :: Int64 is twice the spin 2s of the observable.\nl2m :: Int64 is twice the maximal angular momentum 2l_max of the components of the observable. \nget_comp :: Function is a function get_comp(l2 :: Int64, m2 :: Int64) :: Terms that sends the component specified by a tuple of integers (2l2m) where sleq lleq l_max -lleq mleq l to a list of terms that specifies the expression of the component. \nstored_q :: Bool is a boolean that specifies whether or not each component of the observable is stored.\ncomps :: Dict{Tuple{Int64, Int64}, Terms} stores each component of the observable in the format of a dictionary whose keys are the tuples of integers (2l2m) and values are the lists of terms that specifies the expression of the component. \n\n\n\n\n\n","category":"type"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"It can be initialised with the following methods ","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"SphereObs(s2 :: Int64, l2m :: Int64, get_comp :: Function)\nSphereObs(s2 :: Int64, l2m :: Int64, cmps :: Dict{Tuple{Int64, Int64}, Terms})","category":"page"},{"location":"models/#FuzzifiED.SphereObs-Tuple{Int64, Int64, Function}","page":"Built-in models","title":"FuzzifiED.SphereObs","text":"SphereObs(s2 :: Int64, l2m :: Int64, get_comp :: Function) :: SphereObs\n\ninitialises the observable from 2s, 2l_max and the function (lm)Phi_lm\n\nArguments\n\ns2 :: Int64 is twice the spin 2s of the observable.\nl2m :: Int64 is twice the maximal angular momentum 2l_max of the components of the observable. \nget_comp :: Function is a function get_comp(l2 :: Int64, m2 :: Int64) :: Terms that sends the component specified by a tuple of integers (2l2m) where sleq sleq l_max -lleq mleq l to a list of terms that specifies the expression of the component. \n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.SphereObs-Tuple{Int64, Int64, Dict{Tuple{Int64, Int64}, Vector{Term}}}","page":"Built-in models","title":"FuzzifiED.SphereObs","text":"SphereObs(s2 :: Int64, l2m :: Int64, get_comp :: Function) :: SphereObs\n\ninitialises the observable from 2s, 2l_max and a list of Phi_lm specified by a dictionary. \n\nArguments\n\ns2 :: Int64 is twice the spin 2s of the observable.\nl2m :: Int64 is twice the maximal angular momentum 2l_max of the components of the observable. \ncomps :: Dict{Tuple{Int64, Int64}, Terms} stores each component of the observable in the format of a dictionary whose keys are the tuples of integers (2l2m) and values are the lists of terms that specifies the expression of the component. \n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"The following methods explicitly calculates and stores each component","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"StoreComps!(obs :: SphereObs)\nStoreComps(obs :: SphereObs)","category":"page"},{"location":"models/#FuzzifiED.StoreComps!-Tuple{SphereObs}","page":"Built-in models","title":"FuzzifiED.StoreComps!","text":"StoreComps!(obs :: SphereObs)\n\ncalculates and stores each component of the observable obs and replace the function in obs by the list of calculated components. \n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.StoreComps-Tuple{SphereObs}","page":"Built-in models","title":"FuzzifiED.StoreComps","text":"StoreComps(obs :: SphereObs) :: SphereObs\n\ncalculates and stores each component of the observable obs and return a new observable with the list of calculated components. \n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"The multiplication, addition, conjugate and Laplacian operation of an observable is supported ","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"*(fac :: Number, obs :: SphereObs) \n+(obs1 :: SphereObs, obs2 :: SphereObs) \nadjoint(obs :: SphereObs)\n*(obs1 :: SphereObs, obs2 :: SphereObs)\nLaplacian(obs :: SphereObs)","category":"page"},{"location":"models/#Base.:*-Tuple{Number, SphereObs}","page":"Built-in models","title":"Base.:*","text":"*(fac :: Number, obs :: SphereObs) :: SphereObs\n*(obs :: SphereObs, fac :: Number) :: SphereObs\n/(obs :: SphereObs, fac :: Number) :: SphereObs\n-(obs :: SphereObs) :: SphereObs\n\nenables the multiplication of an observable with a number.\n\n\n\n\n\n","category":"method"},{"location":"models/#Base.:+-Tuple{SphereObs, SphereObs}","page":"Built-in models","title":"Base.:+","text":"+(obs1 :: SphereObs, obs2 :: SphereObs) :: SphereObs\n-(obs1 :: SphereObs, obs2 :: SphereObs) :: SphereObs\n\nenables the addition of two observables.\n\n\n\n\n\n","category":"method"},{"location":"models/#Base.adjoint-Tuple{SphereObs}","page":"Built-in models","title":"Base.adjoint","text":"adjoint(obs :: SphereObs) :: SphereObs\n\nenables the Hermitian conjugate of a spherical observable.\n\nbeginaligned\n    Φ^(Ω)=_lm(Φ_lm)^barY^(s)_lm(Ω)=_lm(Φ_lm)^(-1)^s+mY^(-s)_l-m(Ω)\n    (Φ^)_lm=(-1)^s-m(Φ_l-m)^\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"models/#Base.:*-Tuple{SphereObs, SphereObs}","page":"Built-in models","title":"Base.:*","text":"*(obs1 :: SphereObs, obs2 :: SphereObs) :: SphereObs\n\nenables the multiplication of two observable by making use of the composition of two monopole harmonics into one. \n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.Laplacian-Tuple{SphereObs}","page":"Built-in models","title":"FuzzifiED.Laplacian","text":"Laplacian(obs :: SphereObs) :: SphereObs\n\nTakes the Laplacian of an observable\n\n    (^2Φ)_lm=-l(l+1)Φ_lm\n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"The observables can be evaluated either at an angular component or at a real-space point.","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"GetComponent(obs :: SphereObs, l :: Number, m :: Number)\nGetPointValue(obs :: SphereObs, θ :: Float64, ϕ :: Float64)","category":"page"},{"location":"models/#FuzzifiED.GetComponent-Tuple{SphereObs, Number, Number}","page":"Built-in models","title":"FuzzifiED.GetComponent","text":"GetComponent(obs :: SphereObs, l :: Number, m :: Number) :: Terms\n\nreturns an angular component Φ_lm of an observable in the format of a list of terms.\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetPointValue-Tuple{SphereObs, Float64, Float64}","page":"Built-in models","title":"FuzzifiED.GetPointValue","text":"GetPointValue(obs :: SphereObs, θ :: Float64, ϕ :: Float64) :: Terms\n\nevaluates an observable at one point Φ(θϕ) in the format of a list of terms.\n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"Three types of operators, viz. electrons and density operators, and pairing operators are built-in.","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"GetElectronObs(nm :: Int64, nf :: Int64, f :: Int64)\nGetDensityObs(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number})\nGetPairingObs(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number})","category":"page"},{"location":"models/#FuzzifiED.GetElectronObs-Tuple{Int64, Int64, Int64}","page":"Built-in models","title":"FuzzifiED.GetElectronObs","text":"GetElectronObs(nm :: Int64, nf :: Int64, f :: Int64) :: SphereObs\n\nreturns the electron annihilation operator ψ_f\n\nArguments\n\nnf :: Int64 is the number of flavours.\nnm :: Int64 is the number of orbitals.\nf :: Int64 is the index of the flavour to be taken.\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetDensityObs-Tuple{Int64, Int64, Matrix{<:Number}}","page":"Built-in models","title":"FuzzifiED.GetDensityObs","text":"GetDensityObs(nm :: Int64, nf :: Int64[, mat :: Matrix{<:Number}]) :: SphereObs\n\nreturns the density operator n=_ffψ^_fM_ffψ_f\n\nArguments\n\nnf :: Int64 is the number of flavours.\nnm :: Int64 is the number of orbitals.\nmat :: Int64 is the matrix M_ff. Facultative, identity matrix mathbbI by default.\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetPairingObs-Tuple{Int64, Int64, Matrix{<:Number}}","page":"Built-in models","title":"FuzzifiED.GetPairingObs","text":"GetPairingObs(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number}) :: SphereObs\n\nreturns the pair operator Δ=_ffψ_fM_ffψ_f\n\nArguments\n\nnf :: Int64 is the number of flavours.\nnm :: Int64 is the number of orbitals.\nmat :: Int64 is the matrix M_ff.\n\n\n\n\n\n","category":"method"},{"location":"models/#Angular-modes","page":"Built-in models","title":"Angular modes","text":"","category":"section"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"An angular modes object is similar to spherical observables except that it superposes in the rule of Clebsch-Gordan coefficients and does not have the notion of locality.","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"AngModes","category":"page"},{"location":"models/#FuzzifiED.AngModes","page":"Built-in models","title":"FuzzifiED.AngModes","text":"AngModes\n\nThe mutable type AngModes stores angular momentum components of an operator on the sphere Φ_lm and superposes in the rule of Clebsch-Gordan coefficients. The usage is similar to the spherical observables, except that SphereObs superposes in the rule of spherical harmonics and has the notion of locality\n\nFields\n\nl2m :: Int64 is twice the maximal angular momentum 2l_max of the components of the modes object. \nget_comp :: Function is a function get_comp(l2 :: Int64, m2 :: Int64) :: Terms that sends the component specified by a tuple of integers (2l2m) where sleq lleq l_max -lleq mleq l to a list of terms that specifies the expression of the component. \nstored_q :: Bool is a boolean that specifies whether or not each component of the modes object is stored.\ncomps :: Dict{Tuple{Int64, Int64}, Terms} stores each component of the modes object in the format of a dictionary whose keys are the tuples of integers (2l2m) and values are the lists of terms that specifies the expression of the component. \n\n\n\n\n\n","category":"type"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"It can be initialised with the following methods ","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"AngModes(l2m :: Int64, get_comp :: Function)\nAngModes(l2m :: Int64, cmps :: Dict{Tuple{Int64, Int64}, Terms})","category":"page"},{"location":"models/#FuzzifiED.AngModes-Tuple{Int64, Function}","page":"Built-in models","title":"FuzzifiED.AngModes","text":"AngModes(l2m :: Int64, get_comp :: Function) :: AngModes\n\ninitialises the modes object from 2l_max and the function (lm)Phi_lm\n\nArguments\n\nl2m :: Int64 is twice the maximal angular momentum 2l_max of the components of the modes object. \nget_comp :: Function is a function get_comp(l2 :: Int64, m2 :: Int64) :: Terms that sends the component specified by a tuple of integers (2l2m) where sleq sleq l_max -lleq mleq l to a list of terms that specifies the expression of the component. \n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.AngModes-Tuple{Int64, Dict{Tuple{Int64, Int64}, Vector{Term}}}","page":"Built-in models","title":"FuzzifiED.AngModes","text":"AngModes(l2m :: Int64, get_comp :: Function) :: AngModes\n\ninitialises the modes object from 2l_max and a list of Phi_lm specified by a dictionary. \n\nArguments\n\nl2m :: Int64 is twice the maximal angular momentum 2l_max of the components of the modes object. \ncomps :: Dict{Tuple{Int64, Int64}, Terms} stores each component of the modes object in the format of a dictionary whose keys are the tuples of integers (2l2m) and values are the lists of terms that specifies the expression of the component. \n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"The following methods explicitly calculates and stores each component","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"StoreComps!(amd :: AngModes)\nStoreComps(amd :: AngModes)","category":"page"},{"location":"models/#FuzzifiED.StoreComps!-Tuple{AngModes}","page":"Built-in models","title":"FuzzifiED.StoreComps!","text":"StoreComps!(amd :: AngModes)\n\ncalculates and stores each component of the modes object amd and replace the function in amd by the list of calculated components. \n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.StoreComps-Tuple{AngModes}","page":"Built-in models","title":"FuzzifiED.StoreComps","text":"StoreComps(amd :: AngModes) :: AngModes\n\ncalculates and stores each component of the modes object amd and return a new modes object with the list of calculated components. \n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"The multiplication, addition and conjugate of an observable is supported ","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"*(fac :: Number, amd :: AngModes) \n+(obs1 :: AngModes, obs2 :: AngModes) \nadjoint(amd :: AngModes)\n*(obs1 :: AngModes, obs2 :: AngModes)","category":"page"},{"location":"models/#Base.:*-Tuple{Number, AngModes}","page":"Built-in models","title":"Base.:*","text":"*(fac :: Number, amd :: AngModes) :: AngModes\n*(amd :: AngModes, fac :: Number) :: AngModes\n/(amd :: AngModes, fac :: Number) :: AngModes\n-(amd :: AngModes) :: AngModes\n\nenables the multiplication of a mode with a number.\n\n\n\n\n\n","category":"method"},{"location":"models/#Base.:+-Tuple{AngModes, AngModes}","page":"Built-in models","title":"Base.:+","text":"+(obs1 :: AngModes, obs2 :: AngModes) :: AngModes\n-(obs1 :: AngModes, obs2 :: AngModes) :: AngModes\n\nenables the addition of two modes.\n\n\n\n\n\n","category":"method"},{"location":"models/#Base.adjoint-Tuple{AngModes}","page":"Built-in models","title":"Base.adjoint","text":"adjoint(amd :: AngModes) :: AngModes\n\nenables the Hermitian conjugate of a spherical mode.\n\nbeginaligned\n    (Φ^)_lm=(-1)^l+m(Φ_l-m)^\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"models/#Base.:*-Tuple{AngModes, AngModes}","page":"Built-in models","title":"Base.:*","text":"*(obs1 :: AngModes, obs2 :: AngModes) :: AngModes\n\nenables the multiplication of two modes in the rule of CG coefficients. \n\n    Φ_lm=_l_1l_2m_1m_2δ_mm_1+m_2l_1m_1l_2m_2lmΦ_l_1m_1Φ_l_2m_2\n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"One can take out either one or a set of components","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"GetComponent(amd :: AngModes, l :: Number, m :: Number)\nFilterL2(amd :: AngModes, l :: Number) \nFilterComponent(amd :: AngModes, flt) ","category":"page"},{"location":"models/#FuzzifiED.GetComponent-Tuple{AngModes, Number, Number}","page":"Built-in models","title":"FuzzifiED.GetComponent","text":"GetComponent(amd :: AngModes, l :: Number, m :: Number) :: Terms\n\nreturns an angular component Φ_lm of a modes object in the format of a list of terms.\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.FilterL2-Tuple{AngModes, Number}","page":"Built-in models","title":"FuzzifiED.FilterL2","text":"FilterL2(amd :: AngModes, l :: Number) :: AngModes\n\nreturns an angular modes object with modes of a certain total angular momentum filtered out.\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.FilterComponent-Tuple{AngModes, Any}","page":"Built-in models","title":"FuzzifiED.FilterComponent","text":"FilterComponent(amd :: AngModes, flt) :: AngModes\n\nreturns an angular modes object with certain modes filtered out.\n\nArguments\n\namd :: AngModes is the original angular modes\nflt is the filter function whose input is the pair (lm) and output is a logical that indicates whether this mode is chosen. E.g., if one wants to filter out the modes with angular momentum l0, one should put (l, m) -> l == l0.\n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"Three types of operators, viz. electrons and density operators, and pairing operators are built-in.","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"GetElectronMod(nm :: Int64, nf :: Int64, f :: Int64)\nGetPairingMod(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number})\nGetDensityMod(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number})","category":"page"},{"location":"models/#FuzzifiED.GetElectronMod-Tuple{Int64, Int64, Int64}","page":"Built-in models","title":"FuzzifiED.GetElectronMod","text":"GetElectronMod(nm :: Int64, nf :: Int64, f :: Int64) :: AngModes\n\nreturns the modes of electron annihilation operator c_m, with angular momentum s=(N_m-1)2\n\nArguments\n\nnf :: Int64 is the number of flavours.\nnm :: Int64 is the number of orbitals.\nf :: Int64 is the index of the flavour to be taken.\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetPairingMod-Tuple{Int64, Int64, Matrix{<:Number}}","page":"Built-in models","title":"FuzzifiED.GetPairingMod","text":"GetPairingMod(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number}) :: AngModes\n\nreturns the modes of two electrons superposed in the rule of CG coefficients. \n\n    Δ_lm=_m_1m_2δ_mm_1+m_2sm_1sm_2lmc_am_1M_abc_bm_2\n\nArguments\n\nnf :: Int64 is the number of flavours.\nnm :: Int64 is the number of orbitals.\nmat :: Int64 is the matrix M_ff.\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetDensityMod-Tuple{Int64, Int64, Matrix{<:Number}}","page":"Built-in models","title":"FuzzifiED.GetDensityMod","text":"GetDensityMod(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number}) :: AngModes\n\nreturns the modes of electron creation and annihilation superposed in the rule of CG coefficients. \n\n    n_lm=_m_1m_2δ_m-m_1+m_2(-1)^s+m_1s(-m_1)sm_2lmc^_m_1c_m_2\n\nArguments\n\nnf :: Int64 is the number of flavours.\nnm :: Int64 is the number of orbitals.\nmat :: Int64 is the matrix M_ff. Facultative, identity matrix mathbbI by default.\n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Fuzzifino","page":"Fuzzifino","title":"Fuzzifino","text":"","category":"section"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"Fuzzifino is a module for exact diagonalisation (ED) calculation on the fuzzy sphere for systems with both bosons and fermions. The usage is similar to FuzzifiED, with new types SQNDiag, SQNOffd, SConf, SBasis, STerm and SOperator defined. To use the module, include also at the start of your Julia script","category":"page"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"using FuzzifiED.Fuzzifino","category":"page"},{"location":"fuzzifino/#Environment-parameter","page":"Fuzzifino","title":"Environment parameter","text":"","category":"section"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"Libpathino","category":"page"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.Libpathino","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.Libpathino","text":"Libpathino :: String = FuzzifiED_jll.LibpathFuzzifino\n\ndefine path of the Fortran library libfuzzifino.so. You do not need to modify that by yourself. However, if you compile the Fortran codes by yourself, you need to point this to your compiled library. \n\n\n\n\n\n","category":"constant"},{"location":"fuzzifino/#Quantum-numbers","page":"Fuzzifino","title":"Quantum numbers","text":"","category":"section"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"The diagonal and off-diagonal quantum numbers are implemented as","category":"page"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"SQNDiag\nSQNOffd","category":"page"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SQNDiag","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SQNDiag","text":"SQNDiag\n\nThe mutable type SQNDiag records the information of a diagonal mathrmU(1) or ℤ_p quantum number in the form of a symmetry charge\n\nQ=_o=1^N_ofq_fon_fo+_o=1^N_obq_bon_bo\n\nor\n\nQ=_o=1^N_ofq_fon_fo+_o=1^N_obq_bon_bo mathrmmod p\n\nwhere i=1N_U is the index of quantum number, o is the index of site, N_of and N_ob are the number of fermionic and bosonic sites, n_fo=f^_of_o, n_bo=b^_ob_o, and q_foq_bo are a set of symmetry charges that must be integer valued.\n\nFields\n\nname :: String is the name of the diagonal quantum number \nchargef :: Vector{Int64} is the symmetry charge q_fo of each site\nchargeb :: Vector{Int64} is the symmetry charge q_bo of each site\nmodul :: Vector{Int64} is the modulus p, set to 1 for mathrmU(1) SQNDiags. \n\nInitialisation\n\nIt can be initialised by the following method\n\nSQNDiag([name :: String, ]chargef :: Vector{Int64}, chargeb :: Vector{Int64}[, modul :: Int64]) :: SQNDiag\n\nThe arguments name and modul are facultative. By default name is set to \"QN\" and modul is set to 1. \n\n\n\n\n\n","category":"type"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SQNOffd","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SQNOffd","text":"SQNOffd\n\nThe mutable type SQNOffd records the information of an off-diagonal ℤ_p quantum number in the form of a discrete transformation\n\n𝒵 f_o α_fo^* f^(p_fo)_π_fo  f_o^α_fo c^(1-p_fo)_π_fo  b_o^α_bo b^_π_bo\n\nwhere we use a notation c^(1)=c^ and c^0=c for convenience, π_foπ_bo are permutations of 1N_of or N_ob, α_foα_bo are coefficients, and p_fo specified whether or not particle-hole transformation is performed for the fermionic site. Note that one must guarentee that all these transformations commute with each other and also commute with the diagonal QNs. \n\nArguments\n\npermf :: Vector{Int64} is a length-N_of vector that records the fermion permutation π_fo.\npermb :: Vector{Int64} is a length-N_ob vector that records the boson permutation π_bo.\nphf :: Vector{Int64} is a length-N_of vector that records p_fo to determine whether or not to perform a particle-hole transformation\nfacf :: Vector{ComplexF64} is a length-N_of vector that records the factor α_fo in the transformation.\nfacb :: Vector{ComplexF64} is a length-N_ob vector that records the factor α_bo in the transformation.\ncyc :: Int64 is the cycle p. \n\nInitialisation\n\nIt can be initialised by the following method\n\nSQNOffd(permf :: Vector{Int64}, permb :: Vector{Int64}[, phf :: Vector{Int64}][, facf :: Vector{ComplexF64}, facb :: Vector{ComplexF64}][, cyc :: Int64]) :: SQNOffd\nSQNOffd(permf :: Vector{Int64}, permb :: Vector{Int64}, phf_q :: Bool[, fac :: Vector{ComplexF64}, facb :: Vector{ComplexF64}]) :: SQNOffd\n\nThe arguments phf, facf, facb and cyc are facultative. By default ph is set all 0, facf, facb is set to all 1 and cyc is set to 2. If phf_q is a bool and true, then ph is set to all 1. \n\n\n\n\n\n","category":"type"},{"location":"fuzzifino/#Configurations","page":"Fuzzifino","title":"Configurations","text":"","category":"section"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"SConfs","category":"page"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SConfs","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SConfs","text":"SConfs\n\nThe mutable type SConfs stores all the configurations that respects the diagonal quantum numbers (SQNDiag) and also a table to inversely look up the index from the configuration. \n\nFields\n\nnof :: Int64 is the number of fermionic sites.\nnof :: Int64 is the number of bosonic sites.\nnebm :: Int64 is the maximal number of boson occupation.\nncf :: Int64 is the number of configurations.\nconff :: Vector{Int64} is an array of length ncf containing all the fermion configurations. Each configuration is expressed in a binary number. If the o-1-th bit of conf[i] is 1, then the o-th site in the i-th configuration is occupied ; if the bit is 0, then the site is empty. \nconfb :: Vector{Int64} is an array of length ncf containing all the boson configurations. Each configuration is expressed in a binary number that has N_bo 1's and N_eb 0's and the number of 0's following each 1 records the number of bosons in that site. \nnorf :: Int64, nobf :: Int64, lid :: Vector{Int64} and rid :: Vector{Int64} contain the information of Lin table that is used to inversely look up the index i from the configuration. \n\n\n\n\n\n","category":"type"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"It can be generated from the QNDiags.","category":"page"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"SConfs(nof :: Int64, nob :: Int64, nebm :: Int64, secd :: Vector{Int64}, qnd :: Vector{SQNDiag} ; num_th :: Int64 = NumThreads, disp_std :: Bool = !SilentStd)","category":"page"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SConfs-Tuple{Int64, Int64, Int64, Vector{Int64}, Vector{SQNDiag}}","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SConfs","text":"SConfs(nof :: Int64, nob :: Int64, nebm :: Int64, secd :: Vector{Int64}, qnd :: Vector{SQNDiag} ; , num_th :: Int64, disp_std :: Bool) :: Confs\n\ngenerates the configurations from the list of QNDiags. \n\nArguments\n\nnof :: Int64 is the number of fermionic sites N_of.\nnob :: Int64 is the number of bosonic sites N_ob.\nnebm :: Int64 is the maximal number of total bosons.\nsecd :: Vector{Int64} is the set of Q_i for the selected configurations in the sector.\nqnd :: Vector{SQNDiag} is the set of SQNDiags. \nnorf :: Int64 and norb :: Int64 are the number of less significant bits used to generate the Lin table. Facultative, N_of2 and N_ob2 by default.\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\nOutput\n\ncfs :: SConfs is a SConfs object.\n\nNote\n\nIf your qnd has negative entries, QNDiags must contain the total number of particles (i.e., bosons plus fermions).\n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Basis","page":"Fuzzifino","title":"Basis","text":"","category":"section"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"SBasis","category":"page"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SBasis","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SBasis","text":"SBasis\n\nThe mutable type SBasis stores the information of the SBasis that respects both diagonal and off-diagonal quantum numbers. The states in the SBasis is in the form \n\nI=λ_i_I1i_I1+λ_i_I2i_I2++λ_i_Im_Ii_Im_I\n\nwhere i is a direct product state, i.e., the configurations i_Ik are grouped into a state I. \n\nFields\n\ncfs :: SConfs stores the configurations that respect the QNDiags ;\ndim :: Int64 is the dimension of the SBasis ;\nszz :: Int64 records the maximum size max m_g of groups;\ncfgr :: Vector{Int64} is a vector of length cfs.ncf and records which group I each configuration i belong to ;\ncffac :: Vector{ComplexF64} is a vector of length cfs.ncf and records the coefficients λ_i of each configuration ;\ngrel :: Matrix{Int64} is a szz*dim matrix that records the configurations in each group i_Ik (k = 1m_I)\ngrsz :: Vector{Int64} is a vector of length dim that records the size m_I of each group.\n\n\n\n\n\n","category":"type"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"It can be generated by the following methods.","category":"page"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"SBasis(cfs :: SConfs, secf :: Vector{<:Number}, qnf :: Vector{SQNOffd} ; num_th = NumThreads, disp_std = !SilentStd)\nSBasis(cfs :: SConfs)","category":"page"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SBasis-Tuple{SConfs, Vector{<:Number}, Vector{SQNOffd}}","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SBasis","text":"SBasis(cfs :: SConfs, secf :: Vector{ComplexF64}, qnf :: Vector{SQNOffd} ; num_th :: Int64, disp_std :: Bool) :: SBasis\n\ngenerates the SBasis that respects the off-diagonal ℤ_p quantum numbers (secfQNOffd)\n\nArguments\n\ncfs :: SConfs is the diagonal QN–preserving configurations ;\nsecf :: Vector{ComplexF64} is a vector of length the same as the number of discrete symmetries that records the eigenvalue of each transformation in the sector ;\nqnf :: Vector{SQNOffd} is a vector of off-diagonal quantum numbers. \nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\nOutput\n\nbs :: SBasis is the resulting SBasis object\n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SBasis-Tuple{SConfs}","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SBasis","text":"SBasis(cfs :: SConfs) :: SBasis\n\nGenerate a SBasis from the configurations without off-diagonal ℤ_n symmetries.\n\nArguments\n\ncfs :: SConfs is the diagonal QN–preserving configurations ;\n\nOutput\n\nbs :: SBasis is the resulting SBasis object\n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Term","page":"Fuzzifino","title":"Term","text":"","category":"section"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"STerm\nSTerms","category":"page"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.STerm","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.STerm","text":"STerm\n\nThe mutable type STerm records a STerm that looks like Ua^(p_1)_o_1a^(p_2)_o_2 a^(p_l)_o_l in an operator, where positive o denotes fermions and negative o denotes bosons\n\n    a^(0)_o=f_o a^(1)_o=f_o^ a^(0)_-o=b_o a^(1)_-o=b_o^\n\nFields\n\ncoeff :: ComplexF64 records the coefficient U\ncstr :: Vector{Int64} is a length-2l vector (p_1o_1p_2o_2 p_lo_l) recording the operator string\n\nMethod\n\nIt can be generated by the function\n\nSTerm(coeff :: ComplexF64, cstr :: Vector{Int64}) :: ComplexF64\n\n\n\n\n\n","category":"type"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.STerms","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.STerms","text":"STerms is an alias for Vector{STerm} for convenience\n\nInitialisation\n\nSTerms(coeff :: Number, cstr :: Vector{Int64})\n\nGives a STerms with a single STerm.\n\n\n\n\n\n","category":"type"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"The product of terms with a number, the sum and product of terms, adjoint and particle-hole transformation are defined","category":"page"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"*(fac :: Number, tms :: STerms)\n+(tms1 :: STerms, tms2 :: STerms)\n*(tms1 :: STerms, tms2 :: STerms)\nadjoint(tms :: STerms)","category":"page"},{"location":"fuzzifino/#Base.:*-Tuple{Number, Vector{STerm}}","page":"Fuzzifino","title":"Base.:*","text":"*(fac :: Number, tms :: STerms) :: STerms\n-(tms :: STerms) :: STerms\n*(tms :: STerms, fac :: Number) :: STerms\n/(tms :: STerms, fac :: Number) :: STerms\n\nReturn the product of a collection of STerms with a number. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Base.:+-Tuple{Vector{STerm}, Vector{STerm}}","page":"Fuzzifino","title":"Base.:+","text":"+(tms1 :: STerms, tms2 :: STerms) :: STerms\n-(tms1 :: STerms, tms2 :: STerms) :: STerms\n\nReturn the naive sum of two series of STerms by taking their union. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Base.:*-Tuple{Vector{STerm}, Vector{STerm}}","page":"Fuzzifino","title":"Base.:*","text":"*(tms1 :: STerms, tms2 :: STerms) :: STerms\n^(tms :: STerms, pow :: Int64) :: STerms\n\nReturn the naive product of two series of STerms or the power of one STerms. The number of STerms equals the product of the number of STerms in tms1 and tms2. For each STerm in tms1 Ua^(p_1)_o_1 and tms2 Ua^(p_1)_o_1, a new STerm is formed by taking UUa^(p_1)_o_1 a^(p_1)_o_1\n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Base.adjoint-Tuple{Vector{STerm}}","page":"Fuzzifino","title":"Base.adjoint","text":"adjoint(tm :: STerm) :: STerm\nadjoint(tms :: STerms) :: STerms\n\nReturn the Hermitian conjugate of a series of STerms. For each STerm Ua^(p_1)_o_1a^(p_2)_o_2 a^(p_l)_o_l, the adjoint is barUa^(1-p_l)_o_l a^(1-p_2)_o_2a^(1-p_1)_o_1\n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"The terms can be simplified by ","category":"page"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"NormalOrder(tm :: STerm)\nSimplifyTerms(tms :: STerms)","category":"page"},{"location":"fuzzifino/#FuzzifiED.NormalOrder-Tuple{STerm}","page":"Fuzzifino","title":"FuzzifiED.NormalOrder","text":"NormalOrder(tm :: STerm) :: STerms\n\nrearrange a STerm such that \n\nthe creation operators must be commuted in front of the annihilation operator \nthe site index of the creation operators are in ascending order and the annihilation operators in descending order. \n\nreturn a list of STerms whose result is equal to the original STerm. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#FuzzifiED.SimplifyTerms-Tuple{Vector{STerm}}","page":"Fuzzifino","title":"FuzzifiED.SimplifyTerms","text":"SimplifyTerms(tms :: STerms ; cutoff :: Float64 = eps(Float64)) :: STerms\n\nsimplifies the sum of STerms such that \n\neach STerm is normal ordered,\nlike STerms are combined, and STerms with zero coefficients are removed.\n\nArgument\n\ncutoff :: Float64 is the cutoff such that STerms with smaller absolute value of coefficients will be neglected. Facultative, eps(Float64) by default. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Operator","page":"Fuzzifino","title":"Operator","text":"","category":"section"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"SOperator","category":"page"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SOperator","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SOperator","text":"SOperator\n\nThe mutable type SOperator records the sum of terms together with information about its symmetry and the basis of the state it acts on and the basis of the resulting state.\n\nFields\n\nbsd :: SBasis is the basis of the initial state ;\nbsf :: SBasis is the basis of the final state ;\nred_q :: Int64 is a flag that records whether or not the conversion to a sparse martrix can be simplified : if bsd and bsf have exactly the same set of quantum numbers, and the operator fully respects the symmetries, and all the elements in bsd.cffac and bsf.cffac has the same absolute value, then red_q = 1 ; otherwise red_q = 0 ; \nsym_q :: Int64 records the symmetry of the operator : if the matrix is Hermitian, then sym_q = 1 ; if it is symmetric, then sym_q = 2 ; otherwise sym_q = 0 ;\nntm :: Int64 is the number of terms ;\nnc :: Int64 is the maximum number of operators in an operator string\ncstrs :: Matrix{Int64} is a matrix recording the operator string of each term. Each column corresponds to a term and is padded to the maximum length with -1's.\ncoeffs :: Vector{ComplexF64} corresponds to the coefficients in each term.\n\n\n\n\n\n","category":"type"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"It can be generated by the following methods.","category":"page"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"SOperator(bsd :: SBasis, bsf :: SBasis, terms :: STerms ; red_q :: Int64 = 0, sym_q :: Int64 = 0)","category":"page"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SOperator-Tuple{SBasis, SBasis, Vector{STerm}}","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SOperator","text":"SOperator(bsd :: SBasis[, bsf :: SBasis], terms :: STerms ; red_q :: Int64, sym_q :: Int64, num_th :: Int64, disp_std :: Bool) :: SOperator\n\ngenerates an operator object from a series of terms. \n\nArguments\n\nbsd :: SBasis is the basis of the initial state ;\nbsf :: SBasis is the basis of the final state. Facultative, the same as bsd by default. \nterms :: STerms records the terms ; \nred_q :: Int64 is a flag that records whether or not the conversion to a sparse martrix can be simplified : if bsd and bsf have exactly the same set of quantum numbers, and the operator fully respects the symmetries, and all the elements in bsd.cffac and bsf.cffac has the same absolute value, then red_q = 1 ; otherwise red_q = 0 ; Facultative, if bsf is not given, 1 by default, otherwise 0 by default.\nsym_q :: Int64 records the symmetry of the operator : if the matrix is Hermitian, then sym_q = 1 ; if it is symmetric, then sym_q = 2 ; otherwise sym_q = 0. Facultative, if bsf is not given, 1 by default, otherwise 0 by default.\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"The product of an operator on a state and the inner product of a final state, an operator and an initial state can be calculated by","category":"page"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"*(op :: SOperator, st_d :: Vector{ComplexF64} ; num_th = NumThreads, disp_std = !SilentStd)\n*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, op :: SOperator, st_d :: Vector{ComplexF64} ; num_th = NumThreads, disp_std = !SilentStd)","category":"page"},{"location":"fuzzifino/#Base.:*-Tuple{SOperator, Vector{ComplexF64}}","page":"Fuzzifino","title":"Base.:*","text":"*(op :: SOperator, st_d :: Vector{ComplexF64} ; num_th :: Int64, disp_std :: Bool) :: Vector{ComplexF64}\n*(op :: SOperator, st_d :: Vector{Float64} ; num_th :: Int64, disp_std :: Bool) :: Vector{Float64}\n\nMeasure the action of an operator on a state. st_d must be of length op.bsd.dim. Returns a vector of length op.bsf.dim that represents the final state.\n\nFacultative arguments\n\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Base.:*-Tuple{Adjoint{ComplexF64, Vector{ComplexF64}}, SOperator, Vector{ComplexF64}}","page":"Fuzzifino","title":"Base.:*","text":"*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, op :: SOperator, st_d :: Vector{ComplexF64} ; num_th :: Int64, disp_std :: Bool) :: ComplexF64\n*(st_fp :: LinearAlgebra.Adjoint{Float64, Vector{Float64}}, op :: SOperator, st_d :: Vector{Float64} ; num_th :: Int64, disp_std :: Bool) :: Float64\n\nMeasuring the inner product between two states and an operator. st_d must be of length op.bsd.dim and st_fp must be of length op.bsf.dim, and st_fp must be an adjoint. \n\nFacultative arguments\n\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Sparse-matrix","page":"Fuzzifino","title":"Sparse matrix","text":"","category":"section"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"The OpMat can be generated from SOperator by the following methods.","category":"page"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"OpMat(op :: SOperator)","category":"page"},{"location":"fuzzifino/#FuzzifiED.OpMat-Tuple{SOperator}","page":"Fuzzifino","title":"FuzzifiED.OpMat","text":"OpMat[{type}](op :: SOperator ; num_th :: Int64, disp_std :: Bool) :: OpMat{type}\n\nGenerates the sparse matrix from the operator. The parameter type is either Float64 or ComplexF64 ; it is facultative, given by ElementType by default. \n\nArguments\n\nop :: SOperator is the operator ;\ntype :: DataType specifies the type of the matrix. It can either be ComplexF64 or Float64. Facultative, the same as ElementType by default\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"After the generation of sparse matrix, the diagonalisation can be condicted with FuzzifiED. ","category":"page"},{"location":"fuzzifino/#Related-examples","page":"Fuzzifino","title":"Related examples","text":"","category":"section"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"test_boson.jl tests the nearest-neighbour tight-binding model H=sum_i(b^dagger_ib_i+1+f^dagger_if_i+1+mathrmhc). The example diagonalises the sector with the number of bosons and fermions both N_o2, and even under the reflection with respect to a bond center imapsto N_o+1-i, and measures the total particle number squared leftsum_i(b_i^dagger b_i+f^dagger_if_i)right^2.\nising_frac_boson.jl calculates the spectrum of 3d Ising model on fuzzy sphere for bosons at fractional filling ν = 12. This example reproduces Figure 12a,b in Voinea 2024.","category":"page"},{"location":"extension/#Other-extensions","page":"Other extensions","title":"Other extensions","text":"","category":"section"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"Apart from ITensor extension, FuzzifiED also provides other extensions, viz. HDF5 extension, KrylovKit extension, CUDA extension and SparseArrays extension. ","category":"page"},{"location":"extension/#HDF5-extension","page":"Other extensions","title":"HDF5 extension","text":"","category":"section"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"The HDF5 extension supports writing the types Confs, Basis, Terms, Operator, OpMat{ComplexF64} and OpMat{Float64} into HDF5 files and reading them from groups and subgroups in HDF5 format. This extension requires the packages HDF5. To use this extension, include at the heading ","category":"page"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"using HDF5","category":"page"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"A typical file operation process looks like","category":"page"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"h5open(file_name, \"cw\")\n# include the file name as a string \n# Modes : \"cw\" for write and \"r\" for read\n...\nclose(f)","category":"page"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"To write, include in the middle ","category":"page"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"write(f, group_name :: String, cfs :: Confs)\nwrite(f, group_name :: String, bs  :: Basis)\nwrite(f, group_name :: String, tms :: Terms)\nwrite(f, group_name :: String, op  :: Operator)\nwrite(f, group_name :: String, mat :: OpMat{ComplexF64})\nwrite(f, group_name :: String, mat :: OpMat{Float64})","category":"page"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"To read, include in the middle ","category":"page"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"cfs = read(f, group_name :: String, Confs)\nbs  = read(f, group_name :: String, Basis)\ntms = read(f, group_name :: String, Terms)\nop  = read(f, group_name :: String, Operator)\nmat = read(f, group_name :: String, OpMat{ComplexF64})\nmat = read(f, group_name :: String, OpMat{Float64})","category":"page"},{"location":"extension/#SparseArrays-extension","page":"Other extensions","title":"SparseArrays extension","text":"","category":"section"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"The SparseArrays extension supports the conversion between OpMat in FuzzifiED and the SparseMatrixCSC and Matrix format. This extension requires the packages SparseArrays. To use this extension, include at the heading ","category":"page"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"using SparseArrays","category":"page"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"SparseMatrixCSC(mat :: OpMat)\nMatrix(mat :: OpMat)\nOpMat(matcsc :: SparseMatrixCSC)","category":"page"},{"location":"extension/#SparseArrays.SparseMatrixCSC-Tuple{OpMat}","page":"Other extensions","title":"SparseArrays.SparseMatrixCSC","text":"SparseMatrixCSC(mat :: OpMat{ComplexF64}) :: SparseMatrixCSC{Int64,ComplexF64}\nSparseMatrixCSC(mat :: OpMat{Float64}) :: SparseMatrixCSC{Int64,Float64}\n\nconverts the OpMat objects to a SparseMatrixCSC object in the SparseArrays package.\n\n\n\n\n\n","category":"method"},{"location":"extension/#Base.Matrix-Tuple{OpMat}","page":"Other extensions","title":"Base.Matrix","text":"Matrix(mat :: OpMat{ComplexF64}) :: Matrix{ComplexF64}\nMatrix(mat :: OpMat{Float64}) :: Matrix{Float64}\n\nconverts the OpMat objects to a full matrix.\n\n\n\n\n\n","category":"method"},{"location":"extension/#FuzzifiED.OpMat-Tuple{SparseMatrixCSC}","page":"Other extensions","title":"FuzzifiED.OpMat","text":"OpMat(matcsc :: SparseMatrixCSC{Int64,ComplexF64}) :: OpMat{ComplexF64}\nOpMat(matcsc :: SparseMatrixCSC{Int64,Float64}) :: OpMat{Float64}\n\nconverts the SparseMatrixCSC object in the SparseArrays package to an OpMat objects.\n\n\n\n\n\n","category":"method"},{"location":"extension/#KrylovKit-extension","page":"Other extensions","title":"KrylovKit extension","text":"","category":"section"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"The KrylovKit extension supports an interface diagonalising the sparse matrix using the KrylovKit pakage in Julia. This extension requires the packages KrylovKit. To use this extension, include at the heading ","category":"page"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"using KrylovKit","category":"page"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"Besides Arpack in Fortran, we also provide an interface calling KrylovKit in Julia.","category":"page"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"GetEigensystemKrylov(mat :: OpMat{ComplexF64}, nst :: Int64)","category":"page"},{"location":"extension/#FuzzifiED.GetEigensystemKrylov-Tuple{OpMat{ComplexF64}, Int64}","page":"Other extensions","title":"FuzzifiED.GetEigensystemKrylov","text":"GetEigensystemKrylov(mat :: OpMat{ComplexF64}, nst :: Int64 ; initvec :: Vector{ComplexF64}, num_th :: Int64, disp_std :: Bool, kwargs...) :: Tuple{Vector{ComplexF64}, Matrix{ComplexF64}}\nGetEigensystemKrylov(mat :: OpMat{Float64}, nst :: Int64 ; initvec :: Vector{Float64}, num_th :: Int64, disp_std :: Bool, kwargs...) :: Tuple{Vector{Float64}, Matrix{Float64}}\n\nThis method calls the eigsolve from Julia KrylovKit.jl package instead of Arpack from Fortran to calculate the lowest eigenstates of sparse matrix. The performance should be similar. For an example, refer to ising_spectrum_krylov.jl.\n\nArguments\n\nmat :: OpMat{ComplexF64} or mat :: OpMat{Float64} is the matrix ;\nnst :: Int64 is the number of eigenstates to be calculated ;\ntol :: Float64 is the tolerence for the KrylovKit process. The default value is 1E-8 ;\nncv :: Int64 is the maximum dimension of the Krylov subspace. The default value is max(2 * nst, nst + 10). If krylovdim is also given, ncv will not be used.\ninitvec :: Vector{ComplexF64} or initvec :: Vector{Float64} is the initial vector. Facultative, a random initialisation by default ;\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \nkwargs... is the options that will directly sent into eigsolve, see its documentation for detail.\n\nOutput\n\nA length-nst array that has the same type as mat recording the eigenvalues, and \nA dimd*nst matrix that has the same type as mat where every column records an eigenstate. \n\n\n\n\n\n","category":"method"},{"location":"extension/#CUDA-extension","page":"Other extensions","title":"CUDA extension","text":"","category":"section"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"The CUDA extension supports the conversion between OpMat in FuzzifiED and the CuSparseMatrixCSC in CUDA.CUSPARSE as well as the acceleration of diagonalisation on GPU. This extension requires the packages CUDA, KrylovKit and SparseArrays. To use this extension, include at the heading ","category":"page"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"using CUDA, KrylovKit, SparseArrays","category":"page"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"CUSPARSE.CuSparseMatrixCSC(mat :: OpMat{ComplexF64})\nGetEigensystemCuda(mat :: OpMat{ComplexF64}, nst :: Int64)","category":"page"},{"location":"extension/#CUDA.CUSPARSE.CuSparseMatrixCSC-Tuple{OpMat{ComplexF64}}","page":"Other extensions","title":"CUDA.CUSPARSE.CuSparseMatrixCSC","text":"CUSPARSE.CuSparseMatrixCSC(mat :: OpMat{ComplexF64})\nCUSPARSE.CuSparseMatrixCSC(mat :: OpMat{Float64})\n\nconverts the OpMat objects to a CuSparseMatrixCSC object in the CUDA.CUSPARSE package.\n\n\n\n\n\n","category":"method"},{"location":"extension/#FuzzifiED.GetEigensystemCuda-Tuple{OpMat{ComplexF64}, Int64}","page":"Other extensions","title":"FuzzifiED.GetEigensystemCuda","text":"GetEigensystemCuda(mat :: OpMat{ComplexF64}, nst :: Int64 ; initvec :: Vector{ComplexF64}, num_th :: Int64, disp_std :: Bool, kwargs...) :: Tuple{Vector{ComplexF64}, CuArray{ComplexF64, 2, CUDA.DeviceMemory}}\nGetEigensystemCuda(mat :: OpMat{Float64}, nst :: Int64 ; initvec :: Vector{Float64}, num_th :: Int64, disp_std :: Bool, kwargs...) :: Tuple{Vector{Float64}, CuArray{Float64, 2, CUDA.DeviceMemory}}\n\nThis method uses Julia KrylovKit package to calculate the lowest eigenstates of sparse matrix. The sparse matrix multiplication is realised by CUDA.CUSPARSE. For an example, refer to ising_spectrum_cuda.jl.\n\nArguments\n\nmat :: OpMat{ComplexF64} or mat :: OpMat{Float64} is the matrix ;\nnst :: Int64 is the number of eigenstates to be calculated ;\ntol :: Float64 is the tolerence for the KrylovKit process. The default value is 1E-8 ;\nncv :: Int64 is the maximum dimension of the Krylov subspace. The default value is max(2 * nst, nst + 10). If krylovdim is also given, ncv will not be used.\ninitvec is the initial vector. Facultative, a random initialisation CUDA.rand(T, mat.dimd) by default ;\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \nkwargs... is the options that will directly sent into eigsolve, see its documentation for detail.\n\nOutput\n\nA length-nst array that has the same type as mat recording the eigenvalues, and \nA dimd*nst matrix that has the same type as mat where every column records an eigenstate. \n\n\n\n\n\n","category":"method"},{"location":"releases/#Release-notes","page":"Releases","title":"Release notes","text":"","category":"section"},{"location":"releases/#Version-0.x","page":"Releases","title":"Version 0.x","text":"","category":"section"},{"location":"releases/#Version-0.10","page":"Releases","title":"Version 0.10","text":"","category":"section"},{"location":"releases/#Version-0.10.4-(30-November,-2024)","page":"Releases","title":"Version 0.10.4 (30 November, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Split ITensorsExt and EasySweepExt.\nDefine a new SiteType \"FuzzyFermion\" for ITensors to avoid overwriting \"Fermion\" in ITensorsExt.\nChange the names of Density and Electron to avoid conflict with other packages.\nCreate the alias Terms and STerms.\nFix bugs in converting OpSum to Terms.\nImprove the interface for ITensor extension.","category":"page"},{"location":"releases/#Version-0.10.3-(28-November,-2024)","page":"Releases","title":"Version 0.10.3 (28 November, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add options for DMRG. \nOptimise the implementation of confs in Fuzzifino.\nAdd the examples of fractional filling.","category":"page"},{"location":"releases/#Version-0.10.1-(25-November,-2024)","page":"Releases","title":"Version 0.10.1 (25 November, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add CUDA extension. \nAdd interface with KrylovKit.","category":"page"},{"location":"releases/#Version-0.10.0-(24-November,-2024)","page":"Releases","title":"Version 0.10.0 (24 November, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add module Fuzzifino for boson-fermion systems.","category":"page"},{"location":"releases/#Version-0.9","page":"Releases","title":"Version 0.9","text":"","category":"section"},{"location":"releases/#Version-0.9.3-(23-November,-2024)","page":"Releases","title":"Version 0.9.3 (23 November, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Move HDF5 and ITensor to extensions\nModify ITensor extension interfaces in alignment with the update of ITensor.","category":"page"},{"location":"releases/#Version-0.9.2-(16-September,-2024)","page":"Releases","title":"Version 0.9.2 (16 September, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add the example of Ising generators and Sp(3) CFT.","category":"page"},{"location":"releases/#Version-0.9.1-(13-September,-2024)","page":"Releases","title":"Version 0.9.1 (13 September, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Allow input of initial vectors for diagonalisation. (We acknowledge Andrew Fitzpatrick for the suggestion.)","category":"page"},{"location":"releases/#Version-0.9.0-(11-September,-2024)","page":"Releases","title":"Version 0.9.0 (11 September, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add feature of angular modes observables.\nFix typos and bugs.","category":"page"},{"location":"releases/#Version-0.8","page":"Releases","title":"Version 0.8","text":"","category":"section"},{"location":"releases/#Version-0.8.2-(28-July,-2024)","page":"Releases","title":"Version 0.8.2 (28 July, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Fix bugs in GetDenIntTerms and multiplication in SphereObs. ","category":"page"},{"location":"releases/#Version-0.8.0-(26-July,-2024)","page":"Releases","title":"Version 0.8.0 (26 July, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Improve the performance of SimplifyTerms. \nAdd file operation. ","category":"page"},{"location":"releases/#Version-0.7","page":"Releases","title":"Version 0.7","text":"","category":"section"},{"location":"releases/#Version-0.7.2-(24-July,-2024)","page":"Releases","title":"Version 0.7.2 (24 July, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add example and support for surface CFTs. \nAdd example of Ising cusp.","category":"page"},{"location":"releases/#Version-0.7.1-(11-June,-2024)","page":"Releases","title":"Version 0.7.1 (11 June, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add some new interfaces for built-in operators. \nAdd new examples. \nFix bugs","category":"page"},{"location":"releases/#Version-0.7.0-(9-June,-2024)","page":"Releases","title":"Version 0.7.0 (9 June, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Revise the implementation of diagonal and off-diagonal quantum number. ","category":"page"},{"location":"releases/#Version-0.6","page":"Releases","title":"Version 0.6","text":"","category":"section"},{"location":"releases/#Version-0.6.3-(8-June,-2024)","page":"Releases","title":"Version 0.6.3 (8 June, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add support for calculating entanglement spectrum. \nAdd global parameters to control the number of threads, the output and the path of the dynamic library. \nFix bugs. ","category":"page"},{"location":"releases/#Version-0.6.0-(5-June,-2024)","page":"Releases","title":"Version 0.6.0 (5 June, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add support for full diagonalisation. \nFix bugs and typos.\nReady for formal release !","category":"page"},{"location":"releases/#Version-0.5","page":"Releases","title":"Version 0.5","text":"","category":"section"},{"location":"releases/#Version-0.5.8-(3-June,-2024)","page":"Releases","title":"Version 0.5.8 (3 June, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Change the binary dependence to Julia Binary Builder. ","category":"page"},{"location":"releases/#Version-0.5.0-(30-May,-2024)","page":"Releases","title":"Version 0.5.0 (30 May, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Enable simplification of terms.\nAdd general observables and built-in electrons and density operators. \nReorganise the realisations of built-in models.\nCancel ITensorMPOConstruction dependence. ","category":"page"},{"location":"releases/#Version-0.4","page":"Releases","title":"Version 0.4","text":"","category":"section"},{"location":"releases/#Version-0.4.3-(29-May,-2024)","page":"Releases","title":"Version 0.4.3 (29 May, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add QNU truncation for ITensor use.\nChange the Fortran code to be robust against QNU breaking terms\nAdd built-in density-density interaction. \nAdd built-in 3-state Potts model.\nAdd built-in Ising model with magnetic line defect. ","category":"page"},{"location":"releases/#Version-0.4.0-(28-May,-2024)","page":"Releases","title":"Version 0.4.0 (28 May, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add support for DMRG.\nAdd convertion from diagonal QNs to sites. \nAdd the support of mathbbZ_n diagonal quantum numbers in Confs.\nMerge the submodules to the main package. \nAdd Ising model in X basis.  \nAdd functions in built-in models to export diagonal QNs. ","category":"page"},{"location":"releases/#Version-0.3","page":"Releases","title":"Version 0.3","text":"","category":"section"},{"location":"releases/#Version-0.3.0-(27-May,-2024)","page":"Releases","title":"Version 0.3.0 (27 May, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add the support for Hamiltonians with real elements. \nAdd conversion with SparseMatrixCSC. \nAdd the conversion from terms to OpSum.\nAdd the look-up of configurations. \nFor the built-in Ising model, add density operator.\nAdd built-in mathrmSp(N) model. ","category":"page"},{"location":"releases/#Version-0.2","page":"Releases","title":"Version 0.2","text":"","category":"section"},{"location":"releases/#Version-0.2.0-(26-May,-2024)","page":"Releases","title":"Version 0.2.0 (26 May, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add operations of terms.\nAdd built-in Ising model. ","category":"page"},{"location":"#FuzzifiED.jl","page":"Home","title":"FuzzifiED.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package FuzzifiED is designed to do exact diagonalisation (ED) calculations on the fuzzy sphere, and also facilitates the DMRG calculations by ITensor. It can also be used for generic fermionic and bosonic models. Using this package, you can reproduce almost all the ED results in fuzzy sphere works.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If this package is helpful in your research, we would appreciate it if you mention in the acknowledgement. If you have any questions, please contact Zheng Zhou (周正) at fuzzified@zhengzhou.page.","category":"page"},{"location":"#Install","page":"Home","title":"Install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the package, please first enter Julia by entering in the command line julia, and then enter the commands","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg ; Pkg.add(\"FuzzifiED\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Include at the start of your Julia script","category":"page"},{"location":"","page":"Home","title":"Home","text":"using FuzzifiED","category":"page"},{"location":"#Useful-information","page":"Home","title":"Useful information","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Download Julia at this link. \nWe have registered FuzzifiED at Julia General Registry ! The package regisitry may have some delay, to bring up to date, use Pkg.Registry.update(), or install from the github repositories ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/FuzzifiED/FuzzifiED_jll.jl\")\nPkg.add(url=\"https://github.com/FuzzifiED/FuzzifiED.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"We are migrating the GitHub repositories from the personal account to the organisation account FuzzifiED. The old repositories will still be accessible. \nJupyter Notebook is highly recommended as it allows you to run Julia (and Python) just like running a Mathematica notebook. N.b., you may need to install the package IJulia by hand to use Jupyter notebook ; in Jupyter notebooks, you may need to define how many threads OpenMP uses by hand in FuzzifiED.NumThreads.\nThe package is under active development, so certain interfaces may get changed, superceded or obsolete. We are sorry for any possible inconvenience. \nFor the DMRG calculation, due to the change of interface in update of ITensors v0.7, now both package ITensors and ITensorMPS need to be installed. \nThe supporting Fortran code for ED is stored at the GitHub Repo at FuzzifiED/FuzzifiED_Fortran.","category":"page"},{"location":"#Outline","page":"Home","title":"Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"intro.md\",\n    \"example.md\",\n    \"core.md\",\n    \"models.md\",\n    \"itensors.md\",\n    \"extension.md\",\n    \"fuzzifino.md\",\n    \"releases.md\"\n]\nDepth = 2","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"core.md\",\n    \"models.md\",\n    \"itensors.md\",\n    \"extension.md\",\n    \"fuzzifino.md\"\n]","category":"page"},{"location":"example/#FuzzifiED-explained-in-an-example","page":"Examples","title":"FuzzifiED explained in an example","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"In this example, we will illustrate how to use FuzzifiED to calculate the spectrum of Ising model on fuzzy sphere and how to calculate the OPE coefficient lambda_sigmasigmaepsilon by measuring the expectation value of the density operator n^z. ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"The examples can be found in the directory examples. Two versions of this example is provided. The first uses the built-in functions for quantum numbers and operators to calculate the observables and is stored in tutorial_ising.jl. The second does not use the built-in example and is stored in tutorial_ising_primitive.jl. ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"In addition, an example of how FuzzifiED can facilitate DMRG calculation is given. The example contains two versions. The first uses MPO and dmrg functions of the ITensor package and is stored in tutorial_ising_dmrg.jl. The second uses the EasySweep function in the package which further wraps the dmrg function to facilitate the management of sweeps and is stored in tutorial_ising_dmrg_easysweep.jl. ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"We also append in the end a list of given examples at the end of the page.","category":"page"},{"location":"example/#Exact-diagonalisation-with-FuzzifiED","page":"Examples","title":"Exact diagonalisation with FuzzifiED","text":"","category":"section"},{"location":"example/#Implement-the-diagonal-quantum-numbers-and-generate-the-configurations","page":"Examples","title":"Implement the diagonal quantum numbers and generate the configurations","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"FuzzifiED supports mathrmU(1) diagonal quantum numbers (QNDiag) ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Q_i=sum_o=1^N_oq_ion_o","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"or mathbbZ_n diagonal quantum numbers with period P_i","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Q_i=sum_o=1^N_oq_ion_o mathrmmod P_i","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"where i=1dotsN_U is the index of diagonal quantum numbers, o is the index of sites, n_o=c^dagger_oc_o, and q_o is a set of coefficients that must be integer-valued. ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"There are two diagonal quantum numbers in the Ising model, viz. the particle number and the angular momentum","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"beginaligned\nQ_1=N_e q_1msigma=1\nQ_2=2L_zq_2msigma=2m\nendaligned","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"where the site index o contains both m and sigma. In the code, we store the sites with the same m together, viz. we store the spin-up sites in odd o=13dots2N_m-1 and the spin-down sites in even o=24dots2N_m. We look at the L_z=0 half-filled sector. ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"These two diagonal quantum numbers are built in with functions GetNeQNDiag and GetLz2QNDiag and the configurations can be generated with function Confs. ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"# Inputing the basic setups\nnm = 12\nqnd = [ \n    GetNeQNDiag(2 * nm), \n    GetLz2QNDiag(nm, 2) \n]\ncfs = Confs(2 * nm, [nm, 0], qnd)","category":"page"},{"location":"example/#Primitive-version","page":"Examples","title":"Primitive version","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"Alternatively, you can put in the diagonal quantum numbers QNDiag by hand by specifying the symmetry charges q_o of the sites, and facultatively the name and the modulus","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"nf = 2\nnm = 8\nno = nf * nm\ns = .5 * (nm - 1)\nne = div(no, 2)\n# Record the QNDiag\nqnd = [ \n    # Number of electrons Ne\n    QNDiag(fill(1, no)), \n    # Twice angular momentum 2Lz\n    QNDiag([ (o - 1) ÷ nf * 2 - (nm - 1) for o = 1 : no ])\n]\ncfs = Confs(no, [ne, 0], qnd)","category":"page"},{"location":"example/#Implement-the-off-diagonal-\\mathbb{Z}_p-symmetries-and-initialise-the-basis","page":"Examples","title":"Implement the off-diagonal mathbbZ_p symmetries and initialise the basis","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"FuzzifiED supports off diagonal discrete mathbbZ_p symmetries in the form of ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"mathscrZ c_oto alpha_o^* c^(p_o)_pi_oquad c_o^daggerto alpha_o c^(1-p_o)_pi_o","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"where we use a notation c^(1)=c^dagger and c^0=c for convenience, where pi_o is a permutation of 1dots N_o, alpha_o is a coefficient, and p_o specified whether or not particle-hole transformation is performed for the site. Note that one must guarentee that all these transformations commute with each other and also commute with the diagonal quantum numbers. ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"After implementing these symmetries, a state in the new basis should look like ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Irangle=lambda_i_I1i_I1rangle+lambda_i_I2i_I2rangle+cdots+lambda_i_Im_Ii_Im_Irangle","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"where the irangle's are configurations in the Confs generated in the last section. The Irangle is a linear combination, and can be regarded as a grouping of m_I configurations.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"The function used to implement the discrete symmetries is Basis. There are three mathbbZ_2 transformations in the Ising model, viz. the particle-hole transformation mathscrP, the pi-rotation along the y-axis mathscrR_y and the flavour (Ising) symmetry mathscrZ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"beginaligned\n    mathscrPc^dagger_sigma mtosigma c_-sigmam\n    mathscrZc^dagger_sigma mto c^dagger_-sigmam\n    mathscrR_yc^dagger_sigma mto c^dagger_sigma-m\nendaligned","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"These three symmetries are built in with functions GetParityQNOffd, GetFlavPermQNOffd and GetRotyQNOffd. Thus, if we want to look at the all-positive sector","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"qnf = [ \n    GetParityQNOffd(nm, 2, [2, 1], [-1, 1]), \n    GetFlavPermQNOffd(nm, 2, [2, 1]), \n    GetRotyQNOffd(nm, 2) \n]\nbs = Basis(cfs, [1, 1, 1], qnf)\n# The second argument gives the eigenvalues under the transformations, for Z_2 put 1,-1 ; for Z_n put exp(2im*pi*q/p)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"If no discrete symmetry is needed, one can simply put instead bs = Basis(conf)","category":"page"},{"location":"example/#Primitive-version-2","page":"Examples","title":"Primitive version","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"Alternatively, you can put in the diagonal quantum numbers QNOffd by hand by specifying the permutations pi_o of the sites, and facultatively the particle-hole transformation p_o, the factor alpha_o and the cycle. ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"# Record a QNOffd by site permutation (and facultatives particle-hole, factor, cycle)\nqnf = [ \n    # Parity (Particle-hole)\n    QNOffd([ isodd(o) ? o + 1 : o - 1 for o = 1 : no], true, ComplexF64[ isodd(o) ? -1 : 1 for o = 1 : no]),\n    # Flavour symmetry\n    QNOffd([ isodd(o) ? o + 1 : o - 1 for o = 1 : no]),\n    # Y-axis pi-rotation\n    QNOffd([ isodd(o) ? no - o : no + 2 - o for o = 1 : no], ComplexF64(-1) .^ (collect(0 : nm * nf - 1) .÷ nf))\n]\nbs = Basis(cfs, [1, 1, 1], qnf) ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Please refer to the documenation if you want to implement mathbbZ_n2 symmetries. ","category":"page"},{"location":"example/#Record-the-Hamiltonian-terms","page":"Examples","title":"Record the Hamiltonian terms","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"The operators in the form of the sum of product of c and c^dagger's are supported ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Phi=sum_t=1^N_tU_tc^(p_t1)_o_t1c^(p_t2)_o_t2dots c^(p_tl)_o_tl","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"where c^(0)=c and c^(1)=c^dagger. Here the operator string sum is recorded together with the basis of the initial state and the basis of the final state. ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"The Hamiltonian for the fuzzy sphere Ising model","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"H=sum_m_1m_2m_3m_4U_m_1m_2m_3m_4delta_m_1+m_2m_3+m_4c^dagger_m_1uparrowc^dagger_m_2downarrowc_m_3downarrowc_m_4uparrow-hsum_m(c^dagger_muparrowc_mdownarrow+mathrmhc)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"can be recorded as the sum of a density-density interaction and a polarisation term, which are built-in with the functions GetDenIntTerms and GetPolTerms. We then use Operator function to record it together with its basis. ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"const σ1 = [  1  0 ;  0  0 ]\nconst σ2 = [  0  0 ;  0  1 ]\nconst σx = [  0  1 ;  1  0 ]\ntms_hmt = SimplifyTerms(\n    GetDenIntTerms(nm, 2, 2 .* [4.75, 1.], σ1, σ2) - \n    3.16 * GetPolTerms(nm, 2, σx) )\nhmt = Operator(bs, tms_hmt)","category":"page"},{"location":"example/#Primitive-version-3","page":"Examples","title":"Primitive version","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"using WignerSymbols\n# Input the parameters of the Hamiltonian\nps_pot = [ 4.75, 1. ] * 2.\nh = 3.16\ntms_hmt = Term[]\n# Go through all the m1-up, m2-down, m3-down, m4-up and m4 = m1 + m2 - m3\nfor m1 = 0 : nm - 1\n    f1 = 0\n    o1 = m1 * nf + f1 + 1\n    m1r = m1 - s\n    for m2 = 0 : nm - 1\n        f2 = 1\n        o2 = m2 * nf + f2 + 1\n        m2r = m2 - s\n        for m3 = 0 : nm - 1\n            f3 = 1\n            o3 = m3 * nf + f3 + 1\n            m3r = m3 - s\n            m4 = m1 + m2 - m3 \n            if (m4 < 0 || m4 >= nm) continue end\n            f4 = 0\n            o4 = m4 * nf + f4 + 1\n            m4r = m4 - s\n            # Calculate the matrix element val from pseudopotentials\n            val = ComplexF64(0)\n            for l in eachindex(ps_pot)\n                if (abs(m1r + m2r) > nm - l || abs(m3r + m4r) > nm - l) break end \n                val += ps_pot[l] * (2 * nm - 2 * l + 1) * wigner3j(s, s, nm - l, m1r, m2r, -m1r - m2r) * wigner3j(s, s, nm - l, m4r, m3r, -m3r - m4r)\n            end \n            # Record the interaction term val, \"Cdag\", o1, \"Cdag\", o2, \"C\", o3, \"C\", o4\n            tms_hmt += Terms(val, [1, o1, 1, o2, 0, o3, 0, o4])\n        end\n    end\n    o1x = o1 + 1\n    # Record the transverse field term\n    tms_hmt += Terms(-h, [1, o1, 0, o1x])\n    tms_hmt += Terms(-h, [1, o1x, 0, o1])\nend\n# Generate the Hamiltonian operator\nhmt = Operator(bs, tms_hmt)","category":"page"},{"location":"example/#Generate-the-sparse-matrix-and-diagonalise","page":"Examples","title":"Generate the sparse matrix and diagonalise","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"After specifying the Hamiltonian, we then use Operator to record also the basis and use OpMat to generate a sparse matrix from the operator. To get the 10 lowest eigenstates and their energies","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"hmt = Operator(bs, tms_hmt)\nhmt_mat = OpMat(hmt)\nenrg, st = GetEigensystem(hmt_mat, 10)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Matrices with real elements can be generated by specifying OpMat{Float64}(hmt) or setting FuzzifiED.ElementType = Float64. ","category":"page"},{"location":"example/#Write-the-sparse-matrix-into-HDF5-file","page":"Examples","title":"Write the sparse matrix into HDF5 file","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"It is sometimes needed to write the sparse matrix into file to avoid extra effort to generate it again in another calculation. ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"using HDF5 \nf = h5open(\"data.h5\", \"cw\")\nwrite(f, \"hmt_mat\", hmt_mat)\nclose(f)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"To read from the file","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"f = h5open(\"data.h5\", \"r\") \nhmt_mat = read(f, \"hmt_mat\", OpMat{ComplexF64})\nclose(f)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Apart from OpMat, the supported types for writing include Confs, Basis, Terms, Operator, OpMat{ComplexF64} and OpMat{Float64}. ","category":"page"},{"location":"example/#Measuring-the-angular-momentum","page":"Examples","title":"Measuring the angular momentum","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"We can measure the inner product of a final state, an operator or its matrix and an initial state or the action of an operator or its matrix on a state by directly using the * operator. The total angular momentum L^2 is built-in with function GetL2Terms. The following code measures the angular momentum of each eigenstate and verify whether Trangle is an eigenstate of L^2 by measuring ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"L^2Trangle=L^2Tranglequadfraclangle TL^2Trangle^2langle TTranglelangle L^2TL^2Trangle","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"tms_l2 = GetL2Terms(nm, 2)\nl2 = Operator(bs, tms_l2)\nl2_mat = OpMat(l2)\nl2_val = [ st[:, i]' * l2_mat * st[:, i] for i in eachindex(enrg)]\n@show l2_val\n\nst_T = st[:, 3]\nst_L2T = l2_mat * st[:, 3]\n@show abs(st_L2T' * st_T) ^ 2 / ((st_T' * st_T) * (st_L2T' * st_L2T))","category":"page"},{"location":"example/#Primitive-version-4","page":"Examples","title":"Primitive version","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"By definition","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"beginaligned\nL^2=L^+L^-+(L^z)^2-L^z\nL^z=sum_sigma mmc^dagger_mc_m\nL^pm=sum_sigma msqrt(smp m)(spm m+1)c^dagger_mpm 1c_m\nendaligned","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"The construction of the operator can be simplified by the addition, multiplication, Hermitian conjugate and simplification of terms. ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"tms_lz = \n    [ begin m = div(o - 1, nf)\n        Term(m - s, [1, o, 0, o])\n    end for o = 1 : no ]\ntms_lp = \n    [ begin m = div(o - 1, nf)\n        Term(sqrt(m * (nm - m)), [1, o, 0, o - nf])\n    end for o = nf + 1 : no ]\ntms_lm = tms_lp' \ntms_l2 = SimplifyTerms(tms_lz * tms_lz - tms_lz + tms_lp * tms_lm)","category":"page"},{"location":"example/#Go-through-all-the-sectors","page":"Examples","title":"Go through all the sectors","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"One can repeat the calculation for all the sectors and records the results","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"result = []\nfor P in [1, -1], Z in [1, -1], R in [1, -1]\n    bs = Basis(cfs, [P, Z, R], qnf)\n    hmt = Operator(bs, tms_hmt)\n    hmt_mat = OpMat(hmt)\n    enrg, st = GetEigensystem(hmt_mat, 10)\n\n    l2 = Operator(bs, tms_l2)\n    l2_mat = OpMat(l2)\n    l2_val = [ st[:, i]' * l2_mat * st[:, i] for i in eachindex(enrg)]\n\n    for i in eachindex(enrg)\n        push!(result, round.([enrg[i], l2_val[i], P, Z], digits = 6))\n    end\nend","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"We then sort the eigenstates, find the energy of ground state and stress tensor, and calibrate the scaling dimensions. ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"sort!(result, by = st -> real(st[1]))\nenrg_0 = result[1][1]\nenrg_T = filter(st -> st[2] ≊ 6 && st[3] ≊ 1 && st[4] ≊ 1, result)[1][1]\nresult_dim = [ [ 3 * (st[1] - enrg_0) / (enrg_T - enrg_0) ; st] for st in result ]\nfor P in (1, -1), Z in (1, -1)\n    display(permutedims(hcat(\n        filter(st -> st[4] ≊ P && st[5] ≊ Z, result_dim)...\n    )))\nend","category":"page"},{"location":"example/#Measuring-the-density-operator","page":"Examples","title":"Measuring the density operator","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"Similar process can be used to calculate the OPE coefficient by measuring the density operator, by definition ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"lambda_sigmasigmaepsilon=fraclanglesigman^z_00epsilonranglelanglesigman^z_00mathbbIranglequad n^z_00=frac1N_msum_sigma msigma c^dagger_sigma mc_sigma m","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"To do that, we need to first repeat the calculation in the mathbbZ_2-odd sector","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"bs1 = Basis(cfs, [1, -1, 1], qnf)\nhmt = Operator(bs1, bs1, tms_hmt ; red_q = 1, sym_q = 1) \nhmt_mat = OpMat(hmt)\nenrg1, st1 = GetEigensystem(hmt_mat, 10)\nst_I = st[:, 1] \nst_e = st[:, 2] \nst_s = st1[:, 1]","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"The SphereObs type stores the information of a local observable on the sphere. In particular, the electron and density operators are built-in. The addition and multiplication of observables are enabled. It can be evaluated at a certain point GetPointValue or angular component with GetComponent. ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"obs_nz = GetDensityObs(nm, 2, [ 1 0 ; 0 -1 ])\ntms_nz = SimplifyTerms(GetComponent(obs_nz, 0.0, 0.0))\nnz = Operator(bs, bs1, tms_nz ; red_q = 1) \n@show abs((st_s' * nz * st_e) / (st_s' * nz * st_I))","category":"page"},{"location":"example/#Primitive-version-5","page":"Examples","title":"Primitive version","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"Alternatively, one can write out the terms of density operator explicitly.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"# Record the density operator n^z\ntms_nz = [ Term(isodd(o) ? 1 / nm : -1 / nm, [1, o, 0, o]) for o = 1 : no]\n# The nz operator sends a state in bs (+) to bs1 (-)\nnz = Operator(bs, bs1, tms_nz ; red_q = 1)\n# Measuring the finite size OPE\n@show abs((st_s' * nz * st_e) / (st_s' * nz * st_I))","category":"page"},{"location":"example/#DMRG-calculations-with-FuzzifiED","page":"Examples","title":"DMRG calculations with FuzzifiED","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"In this example, we calculate the ground state MPS of the fuzzy sphere Ising model by DMRG in ITensor, and use the same objects to do ED calculation and compare the result. ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"We first set-up the calculation by","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"using FuzzifiED\nusing ITensors\nconst σx = [  0  1 ;  1  0 ]\nconst σz = [  1  0 ;  0 -1 ]\n\nnm = 12\nnf = 2\nno = nm * nf","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"The first object we need is the sites. FuzzifiED overloads the fermion type and supports direct generation of the sites from the diagonal quantum numbers by the function GetSites. The Ising model is expressed in the basis of XX-Z so that the flavour symmetry is diagonal. ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"sites = GetSites([\n    GetNeQNDiag(nm * nf), \n    GetLz2QNDiag(nm, nf),\n    GetZnfChargeQNDiag(nm, nf)\n])","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"We then generate the terms of the Hamiltonian using the built-in functions, convert it to OpSum type, and convert it to MPO using the MPO function in ITensor.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"ps_pot = [4.75, 1.] ./ 2\ntms_hmt = SimplifyTerms(\n    GetDenIntTerms(nm, 2, ps_pot) - \n    GetDenIntTerms(nm, 2, ps_pot, σx) - \n    3.16 * GetPolTerms(nm, nf, σz)\n)\n@time mpo_hmt = MPO(OpSum(tms_hmt), sites)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"We then use the all-up state as the initial state. In FuzzifiED, the occupied and empty sites are expressed by 0 and 1, while they are expressed by \"0\" and \"1\" in ITensor, so a conversion to string is needed. ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"cf0 = [ isodd(o) ? 1 : 0 for o = 1 : no ]\nst0 = MPS(sites, string.(cf0))","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"After that, the Hamiltonian MPO and the initial state MPS can be used for input for DMRG calculation. ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Eg, stg = dmrg(mpo_hmt, st0 ; nsweeps = 10, maxdim = [10,20,50,100,200,500], noise = [1E-4,3E-5,1E-5,3E-6,1E-6,3E-7], cutoff = [1E-8])\n@show Eg","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"We then convert these objects for the ED calculate. The configurations can be generated from Sites and a reference configuration by the function Confs. ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"cfs = Confs(sites, cf0)\nbs = Basis(cfs)\nhmt = Operator(bs, tms_hmt)\nhmt_mat = OpMat(hmt)\nenrg, st = GetEigensystem(hmt_mat, 10)\n@show enrg","category":"page"},{"location":"example/#Use-EasySweep-to-manage-DMRG-sweeps","page":"Examples","title":"Use EasySweep to manage DMRG sweeps","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"EasySweep facilitates the management of DMRG process by automatically recording the intermediate results and recovering these results if a job is stopped and run again on HPC. It also manages the gradual increase of maximal bond dimensions and the determination of convergence by the criteria of energy. Before the calculation, we need to define a method to generate MPO from OpSum and Sites. We suggest using MPO_new from package ITensorMPOConstruction, which can be installed through ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"using Pkg ; Pkg.add(url=\"https://github.com/ITensor/ITensorMPOConstruction.jl.git\"); ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"using ITensorMPOConstruction\nfunction MyMPO(os, sites)\n    operatorNames = [ \"I\", \"C\", \"Cdag\", \"N\" ]\n    opCacheVec = [ [OpInfo(ITensors.Op(name, n), sites[n]) for name in operatorNames] for n in eachindex(sites)  ]\n    return MPO_new(os, sites ; basis_op_cache_vec = opCacheVec)\nend","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"We also need to specify a path where the results are stored. ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"path = \"nm_$(nm)/\"\nmkpath(path)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"The Hamiltonian MPO and the sites can be either generated or read from file by the function GetMPOSites. The input is the quantum numbers and the terms or OpSum ; the output is the MPO and the sites","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"ps_pot = [4.75, 1.] ./ 2\ntms_hmt = SimplifyTerms(\n    GetDenIntTerms(nm, 2, ps_pot) - \n    GetDenIntTerms(nm, 2, ps_pot, σx) - \n    3.16 * GetPolTerms(nm, 2, σz)\n)\nqnd = [ \n    GetNeQNDiag(no), \n    GetLz2QNDiag(nm, nf), \n    GetZnfChargeQNDiag(nm, nf) \n]\nhmt, sites = GetMPOSites(\"hmt\", tms_hmt, qnd ; path, mpo_method = MyMPO)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"After generating the initial state MPS, the DMRG calculation of the states mathbbI and epsilon can be done by the EasySweep function.  ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"cf0 = [ isodd(o) ? 1 : 0 for o = 1 : no ]\nst0 = MPS(sites, string.(cf0))\nEg, stg = EasySweep(\"g\", hmt, st0 ; path)\nEe, ste = EasySweep(\"e\", hmt, st0 ; path, proj = [\"g\"])","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"The total angular momentum can be measured by generating the MPO of L^2 and measure the inner product ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"tms_l2 = GetL2Terms(nm, 2)\nl2 = GetMPO(\"l2\", tms_l2, sites ; path)\n@show inner(stg', l2, stg)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"The mathbbZ_2-odd sigma state can be calculated similarly.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"cf1 = cf0\ncf1[1] = 0\ncf1[2] = 1\nst1 = MPS(sites, string.(cf1))\nEs, sts = EasySweep(\"s\", hmt, st1 ; path)","category":"page"},{"location":"example/#List-of-examples","page":"Examples","title":"List of examples","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"The examples of FuzzifiED can be found in the repository examples. Apart from the tutorials that we have introduced above ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"tutorial_ising.jl does the ED calculation of Ising model through the built-in models. \ntutorial_ising_primitive.jl does the ED calculation of Ising model through the primitive functions.\ntutorial_ising_dmrg.jl does the DMRG calculation of Ising model through the dmrg function in ITensor.\ntutorial_ising_dmrg_easysweep.jl does the DMRG calculation of Ising model through the EasySweep function which wraps ITensor.","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"We offer a series of other examples that reproduces various achievements of fuzzy sphere. For a more detailed summary of the background, see the Review of existing work. ","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"ising_spectrum.jl calculates the spectrum of 3d Ising model on fuzzy sphere at N_m = 12. For each (PZR) sector, 20 states are calculated. This example reproduces Table I and Figure 4 in Zhu 2022.\nising_phase_diagram.jl calculates the phase diagram of fuzzy sphere Ising modelby calculating the order parameter langle M^2rangle. This example reproduces Figure 3 in Zhu 2022.\nising_ope.jl calculates various OPE coefficients at N_m = 12 by taking overlaps between CFT states and density operators and composite. This example reproduces Figure 2 and Table I in Hu 2023Mar.\nising_correlator.jl calculates the σσ two-point function on sphere and the σσσσ four-point function on sphere, 0 and . This example reproduces Figures 1c and 2a in Han 2023Jun.\nising_optimisation.jl defines a cost function as the square sum of the deviations of descendants and stress tensor to evaluate the conformal symmetry for Ising model and minimises this cost function to find the best parameter.\nising_full_spectrum.jl calculates the full spectrum of 3d Ising model on fuzzy sphere at N_m = 10 for sector (PZR) = (111).\nising_space_entangle.jl calculates the entanglement entropy of the Ising ground state along the real space cut of θ = 0500π and 0499π respectively, and use these two data to extract finite size F-function without sustracting the IQHE contribution. This example reproduces Figures 3 in Hu 2024.\nising_orbital_entangle.jl calculates the entanglement entropy of the Ising ground state along the orbital space cut at m = 0, and also the entanglement spectrum in the half-filled l_z = 0 1 and  both mathbbZ_2 sectors.\nising_generator.jl examines the quality of conformal symmetry at N_m = 12 by examining the matrix elements of conformal generators P^z + K^z and compare the states (P^z + K^z)Φ with the CFT expectations. This example reproduces Figure 7 in Fardelli 2024.\ndefect_spectrum.jl calculates the spectrum of magnetic line defect in 3d Ising model in l_z = 0 P = 1 and l_z = 1 sectors, calibrated by bulk T. This example reproduces Table I in Hu 2023Aug.\ndefect_correlator.jl calculates the 1-pt function σ and 2-pt function σhatϕ of magnetic line defect in 3d Ising model. The normalisation of the correlators require extra bulk data. This example reproduces Figure 4 in Hu 2023Aug.\ndefect_changing.jl calculates the spectrum of the defect creation and changing operators of the magnetic line defect in 3d Ising model. This example reproduces Table 2 and Figure 5 in Zhou 2024Jan.\ndefect_overlap.jl calculates the g-function of magnetic line defect in 3d Ising model using the ovelaps between the bulk, defect ground state and the lowest defect-creation state. This example reproduces Figure 6 in Zhou 2024Jan.\ncusp_dim.jl calculates the scaling dimension of the cusp of the magnetic line defect in 3d Ising model as a function of the angle θ. This example reproduces Table 2, upper panel in Cuomo 2024.\nsurface_ordinary_spectrum.jl calculates the spectrum of ordinary surface CFT in 3d Ising model calibrated by surface displacement operator D in the orbital boundary scheme. This example reproduces Figures 3 and 4 in Zhou 2024Jul.\nsurface_normal_spectrum.jl calculates the spectrum of normal surface CFT in 3d Ising model calibrated by surface displacement operator D in the orbital boundary scheme. This example reproduces Figure 5 in Zhou 2024Jul.\no3_wf_spectrum.jl calculates the spectrum of mathrmO(3) Wilson-Fisher CFT using the bilayer Heisenberg model. This example reproduces Table I and Figure 2 in Hu 2023Dec.\nso5_spectrum.jl calculates the spectrum of SO(5) DQCP on fuzzy sphere. This example reproduces Table II in Zhou 2023.\nsp3_spectrum.jl calculates the spectrum of Sp(3) CFT on fuzzy sphere. This example reproduces Table I in Zhou 2024Oct.\nising_frac_fermion.jl calculates the spectrum of 3d Ising model on fuzzy sphere for fermions at fractional filling ν = 13. This example reproduces Figure 10 in Voinea 2024.\nising_frac_boson.jl calculates the spectrum of 3d Ising model on fuzzy sphere for bosons at fractional filling ν = 12 with the module Fuzzifino. This example reproduces Figure 12a,b in Voinea 2024.\nising_spectrum_krylov.jl calculates the spectrum of 3d Ising model on fuzzy sphere by calling the eigsolve function in KrylovKit.jl instead of Arpack.\nising_spectrum_cuda.jl calculates the spectrum of 3d Ising model on fuzzy sphere for one sector by performing the sparse matrix multiplication on CUDA.","category":"page"}]
}
